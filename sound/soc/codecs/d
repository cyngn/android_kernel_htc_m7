--- wcd9304.c	2013-09-16 22:50:15.251295737 -0700
+++ /home/shade/dev/cm/10.2/kernel/htc/m7/sound/soc/codecs/wcd9304.c	2013-09-02 02:22:12.405202319 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -34,15 +34,15 @@
 #include <linux/kernel.h>
 #include <linux/gpio.h>
 #include <linux/wait.h>
-#include <linux/irq.h>
-#include <linux/wakelock.h>
-#include <linux/suspend.h>
 #include "wcd9304.h"
 
+#undef pr_info
+#undef pr_err
+#define pr_info(fmt, ...) pr_aud_info(fmt, ##__VA_ARGS__)
+#define pr_err(fmt, ...) pr_aud_err(fmt, ##__VA_ARGS__)
+
 #define WCD9304_RATES (SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|\
 			SNDRV_PCM_RATE_32000|SNDRV_PCM_RATE_48000)
-#define ADC_DMIC_SEL_ADC	0
-#define	ADC_DMIC_SEL_DMIC	1
 
 #define NUM_DECIMATORS 4
 #define NUM_INTERPOLATORS 3
@@ -52,8 +52,7 @@
 #define MBHC_FW_READ_ATTEMPTS 15
 #define MBHC_FW_READ_TIMEOUT 2000000
 
-#define SITAR_JACK_MASK (SND_JACK_HEADSET | SND_JACK_OC_HPHL | \
-			SND_JACK_OC_HPHR | SND_JACK_UNSUPPORTED)
+#define SITAR_JACK_MASK (SND_JACK_HEADSET | SND_JACK_OC_HPHL | SND_JACK_OC_HPHR)
 
 #define SITAR_I2S_MASTER_MODE_MASK 0x08
 
@@ -63,19 +62,13 @@
 #define AIF1_CAP 2
 #define NUM_CODEC_DAIS 2
 #define SLIM_CLOSE_TIMEOUT 1000
-#define COMP_DIGITAL_DB_GAIN_APPLY(a, b) \
-	(((a) <= 0) ? ((a) - b) : (a))
-#define COMP_BRINGUP_WAIT_TIME  3000
-
-#define VDDIO_MICBIAS_MV 1800
-
-#define SITAR_MUX_SWITCH_READY_WAIT_MS 50
 
 struct sitar_codec_dai_data {
 	u32 rate;
 	u32 *ch_num;
 	u32 ch_act;
 	u32 ch_tot;
+	u32 bit_width;
 	u32 ch_mask;
 	wait_queue_head_t dai_wait;
 };
@@ -94,21 +87,12 @@
 #define MBHC_NUM_DCE_PLUG_DETECT 3
 #define SITAR_MBHC_FAKE_INSERT_LOW 10
 #define SITAR_MBHC_FAKE_INSERT_HIGH 80
-#define SITAR_MBHC_FAKE_INSERT_VOLT_DELTA_MV 300
+#define SITAR_MBHC_FAKE_INSERT_VOLT_DELTA_MV 500
 #define SITAR_HS_DETECT_PLUG_TIME_MS (5 * 1000)
 #define SITAR_HS_DETECT_PLUG_INERVAL_MS 100
 #define NUM_ATTEMPTS_TO_REPORT 5
 #define SITAR_MBHC_STATUS_REL_DETECTION 0x0C
-#define SITAR_MBHC_GPIO_REL_DEBOUNCE_TIME_MS 50
-#define SITAR_MBHC_GND_MIC_SWAP_THRESHOLD 2
-#define SITAR_MIC_GND_SWAP_DELAY_US 5000
-#define SITAR_USLEEP_RANGE_TOLERANCE 100
-
-#define CUT_OF_FREQ_MASK 0x30
-#define CF_MIN_3DB_4HZ 0x0
-#define CF_MIN_3DB_75HZ 0x01
-#define CF_MIN_3DB_150HZ 0x02
-
+#define SITAR_MBHC_GPIO_REL_DEBOUNCE_TIME_MS 200
 
 static const DECLARE_TLV_DB_SCALE(digital_gain, 0, 1, 0);
 static const DECLARE_TLV_DB_SCALE(line_gain, 0, 7, 1);
@@ -118,8 +102,7 @@
 	struct snd_kcontrol *kcontrol, int event);
 static int sitar_codec_enable_slimrx(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event);
-static enum sitar_mbhc_plug_type
-sitar_codec_decide_gpio_plug(struct snd_soc_codec *codec);
+
 
 enum sitar_bandgap_type {
 	SITAR_BANDGAP_OFF = 0,
@@ -136,13 +119,11 @@
 	u8 cfilt_sel;
 };
 
-/* Codec supports 2 IIR filters */
 enum {
 	IIR1 = 0,
 	IIR2,
 	IIR_MAX,
 };
-/* Codec supports 5 bands */
 enum {
 	BAND1 = 0,
 	BAND2,
@@ -152,25 +133,6 @@
 	BAND_MAX,
 };
 
-enum {
-	COMPANDER_1 = 0,
-	COMPANDER_2,
-	COMPANDER_MAX,
-};
-
-enum {
-	COMPANDER_FS_8KHZ = 0,
-	COMPANDER_FS_16KHZ,
-	COMPANDER_FS_32KHZ,
-	COMPANDER_FS_48KHZ,
-	COMPANDER_FS_96KHZ,
-	COMPANDER_FS_192KHZ,
-	COMPANDER_FS_MAX,
-};
-
-/* Flags to track of PA and DAC state.
- * PA and DAC should be tracked separately as AUXPGA loopback requires
- * only PA to be turned on without DAC being on. */
 enum sitar_priv_ack_flags {
 	SITAR_HPHL_PA_OFF_ACK = 0,
 	SITAR_HPHR_PA_OFF_ACK,
@@ -178,34 +140,6 @@
 	SITAR_HPHR_DAC_OFF_ACK
 };
 
-struct comp_sample_dependent_params {
-	u32 peak_det_timeout;
-	u32 rms_meter_div_fact;
-	u32 rms_meter_resamp_fact;
-};
-
-struct comp_dgtl_gain_offset {
-	u8 whole_db_gain;
-	u8 half_db_gain;
-};
-
-static const struct comp_dgtl_gain_offset comp_dgtl_gain[] = {
-	{0, 0},
-	{1, 1},
-	{3, 0},
-	{4, 1},
-	{6, 0},
-	{7, 1},
-	{9, 0},
-	{10, 1},
-	{12, 0},
-	{13, 1},
-	{15, 0},
-	{16, 1},
-	{18, 0},
-};
-
-/* Data used by MBHC */
 struct mbhc_internal_cal_data {
 	u16 dce_z;
 	u16 dce_mb;
@@ -225,7 +159,6 @@
 	u16 v_no_mic;
 	u8 npoll;
 	u8 nbounce_wait;
-	s16 adj_v_hs_max;
 };
 
 enum sitar_mbhc_plug_type {
@@ -234,7 +167,6 @@
 	PLUG_TYPE_HEADSET,
 	PLUG_TYPE_HEADPHONE,
 	PLUG_TYPE_HIGH_HPH,
-	PLUG_TYPE_GND_MIC_SWAP,
 };
 
 enum sitar_mbhc_state {
@@ -244,15 +176,16 @@
 	MBHC_STATE_RELEASE,
 };
 
-struct hpf_work {
-	struct sitar_priv *sitar;
-	u32 decimator;
-	u8 tx_hpf_cut_of_freq;
-	struct delayed_work dwork;
+#define HPH_RX_GAIN_MAX 12
+struct htc_ramp_work {
+	struct work_struct rwork;
+	bool ramp_type;
+	int hp_ramp_vol_control;
+	int hp_ramp_vol_gain;
+	int line_ramp_vol_control;
+	int line_ramp_vol_gain;
 };
 
-static struct hpf_work tx_hpf_work[NUM_DECIMATORS];
-
 struct sitar_priv {
 	struct snd_soc_codec *codec;
 	u32 mclk_freq;
@@ -270,14 +203,6 @@
 	int buttons_pressed;
 
 	enum sitar_micbias_num micbias;
-	/* void* calibration contains:
-	 *  struct sitar_mbhc_general_cfg generic;
-	 *  struct sitar_mbhc_plug_detect_cfg plug_det;
-	 *  struct sitar_mbhc_plug_type_cfg plug_type;
-	 *  struct sitar_mbhc_btn_detect_cfg btn_det;
-	 *  struct sitar_mbhc_imped_detect_cfg imped_det;
-	 * Note: various size depends on btn_det->num_btn
-	 */
 	void *calibration;
 	struct mbhc_internal_cal_data mbhc_data;
 
@@ -290,43 +215,29 @@
 	u8 cfilt_k_value;
 	bool mbhc_micbias_switched;
 
-	/* track PA/DAC state */
+	
 	unsigned long hph_pa_dac_state;
 
-	/*track sitar interface type*/
+	
 	u8 intf_type;
 
-	u32 hph_status; /* track headhpone status */
-	/* define separate work for left and right headphone OCP to avoid
-	 * additional checking on which OCP event to report so no locking
-	 * to ensure synchronization is required
-	 */
-	struct work_struct hphlocp_work; /* reporting left hph ocp off */
-	struct work_struct hphrocp_work; /* reporting right hph ocp off */
+	u32 hph_status; 
+	struct work_struct hphlocp_work; 
+	struct work_struct hphrocp_work; 
+
+	u8 hphlocp_cnt; 
+	u8 hphrocp_cnt; 
 
-	u8 hphlocp_cnt; /* headphone left ocp retry */
-	u8 hphrocp_cnt; /* headphone right ocp retry */
 
-	/* Callback function to enable MCLK */
 	int (*mclk_cb) (struct snd_soc_codec*, int);
 
-	/* Work to perform MBHC Firmware Read */
+	
 	struct delayed_work mbhc_firmware_dwork;
 	const struct firmware *mbhc_fw;
 
-	/* num of slim ports required */
+	
 	struct sitar_codec_dai_data dai[NUM_CODEC_DAIS];
 
-	/*compander*/
-	int comp_enabled[COMPANDER_MAX];
-	u32 comp_fs[COMPANDER_MAX];
-	u8  comp_gain_offset[NUM_INTERPOLATORS];
-
-	/* Currently, only used for mbhc purpose, to protect
-	 * concurrent execution of mbhc threaded irq handlers and
-	 * kill race between DAPM and MBHC.But can serve as a
-	 * general lock to protect codec resource
-	 */
 	struct mutex codec_resource_lock;
 
 	struct sitar_mbhc_config mbhc_cfg;
@@ -337,57 +248,16 @@
 	struct work_struct hs_correct_plug_work;
 	bool hs_detect_work_stop;
 	struct delayed_work mbhc_btn_dwork;
-	unsigned long mbhc_last_resume; /* in jiffies */
+	unsigned long mbhc_last_resume; 
+
 
-	bool gpio_irq_resend;
-	struct wake_lock irq_resend_wlock;
+	struct htc_ramp_work audio_vol_ramp_work;
 };
 
 #ifdef CONFIG_DEBUG_FS
 struct sitar_priv *debug_sitar_priv;
 #endif
 
-static const int comp_rx_path[] = {
-	COMPANDER_2,
-	COMPANDER_1,
-	COMPANDER_1,
-	COMPANDER_MAX,
-};
-
-static const struct comp_sample_dependent_params
-		    comp_samp_params[COMPANDER_FS_MAX] = {
-	{
-		.peak_det_timeout = 0x6,
-		.rms_meter_div_fact = 0x9 << 4,
-		.rms_meter_resamp_fact = 0x06,
-	},
-	{
-		.peak_det_timeout = 0x7,
-		.rms_meter_div_fact = 0xA << 4,
-		.rms_meter_resamp_fact = 0x0C,
-	},
-	{
-		.peak_det_timeout = 0x8,
-		.rms_meter_div_fact = 0xB << 4,
-		.rms_meter_resamp_fact = 0x30,
-	},
-	{
-		.peak_det_timeout = 0x9,
-		.rms_meter_div_fact = 0xB << 4,
-		.rms_meter_resamp_fact = 0x28,
-	},
-	{
-		.peak_det_timeout = 0xA,
-		.rms_meter_div_fact = 0xC << 4,
-		.rms_meter_resamp_fact = 0x50,
-	},
-	{
-		.peak_det_timeout = 0xB,
-		.rms_meter_div_fact = 0xC << 4,
-		.rms_meter_resamp_fact = 0x50,
-	},
-};
-
 static int sitar_get_anc_slot(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
@@ -496,7 +366,7 @@
 					kcontrol->private_value)->shift;
 	int value = ucontrol->value.integer.value[0];
 
-	/* Mask first 5 bits, 6-8 are reserved */
+	
 	snd_soc_update_bits(codec, (SITAR_A_CDC_IIR1_CTL + 16 * iir_idx),
 		(1 << band_idx), (value << band_idx));
 
@@ -508,12 +378,12 @@
 				int iir_idx, int band_idx,
 				int coeff_idx)
 {
-	/* Address does not automatically update if reading */
+	
 	snd_soc_write(codec,
 		(SITAR_A_CDC_IIR1_COEF_B1_CTL + 16 * iir_idx),
 		(band_idx * BAND_MAX + coeff_idx) & 0x1F);
 
-	/* Mask bits top 2 bits since they are reserved */
+	
 	return ((snd_soc_read(codec,
 		(SITAR_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx)) << 24) |
 		(snd_soc_read(codec,
@@ -568,18 +438,18 @@
 				int iir_idx, int band_idx,
 				int coeff_idx, uint32_t value)
 {
-	/* Mask top 3 bits, 6-8 are reserved */
-	/* Update address manually each time */
+	
+	
 	snd_soc_write(codec,
 		(SITAR_A_CDC_IIR1_COEF_B1_CTL + 16 * iir_idx),
 		(band_idx * BAND_MAX + coeff_idx) & 0x1F);
 
-	/* Mask top 2 bits, 7-8 are reserved */
+	
 	snd_soc_write(codec,
 		(SITAR_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx),
 		(value >> 24) & 0x3F);
 
-	/* Isolate 8bits at a time */
+	
 	snd_soc_write(codec,
 		(SITAR_A_CDC_IIR1_COEF_B3_CTL + 16 * iir_idx),
 		(value >> 16) & 0xFF);
@@ -632,286 +502,153 @@
 	return 0;
 }
 
-static int sitar_compander_gain_offset(
-	struct snd_soc_codec *codec, u32 enable,
-	unsigned int pa_reg, unsigned int vol_reg,
-	int mask, int event,
-	struct comp_dgtl_gain_offset *gain_offset,
-	int index)
-{
-	unsigned int pa_gain = snd_soc_read(codec, pa_reg);
-	unsigned int digital_vol = snd_soc_read(codec, vol_reg);
-	int pa_mode = pa_gain & mask;
-	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
+static const char * const sitar_ear_pa_gain_text[] = {"POS_6_DB",
+					"POS_2_DB", "NEG_2P5_DB", "NEG_12_DB"};
 
-	pr_debug("%s: pa_gain(0x%x=0x%x)digital_vol(0x%x=0x%x)event(0x%x) index(%d)\n",
-		 __func__, pa_reg, pa_gain, vol_reg, digital_vol, event, index);
-	if (((pa_gain & 0xF) + 1) > ARRAY_SIZE(comp_dgtl_gain) ||
-		(index >= ARRAY_SIZE(sitar->comp_gain_offset))) {
-		pr_err("%s: Out of array boundary\n", __func__);
-		return -EINVAL;
-	}
+static const struct soc_enum sitar_ear_pa_gain_enum[] = {
+		SOC_ENUM_SINGLE_EXT(4, sitar_ear_pa_gain_text),
+};
 
-	if (SND_SOC_DAPM_EVENT_ON(event) && (enable != 0)) {
-		gain_offset->whole_db_gain = COMP_DIGITAL_DB_GAIN_APPLY(
-		  (digital_vol - comp_dgtl_gain[pa_gain & 0xF].whole_db_gain),
-		  comp_dgtl_gain[pa_gain & 0xF].half_db_gain);
-		pr_debug("%s: listed whole_db_gain:0x%x, adjusted whole_db_gain:0x%x\n",
-			 __func__, comp_dgtl_gain[pa_gain & 0xF].whole_db_gain,
-			 gain_offset->whole_db_gain);
-		gain_offset->half_db_gain =
-				comp_dgtl_gain[pa_gain & 0xF].half_db_gain;
-		sitar->comp_gain_offset[index] = digital_vol -
-						 gain_offset->whole_db_gain ;
-	}
-	if (SND_SOC_DAPM_EVENT_OFF(event) && (pa_mode == 0)) {
-		gain_offset->whole_db_gain = digital_vol +
-					     sitar->comp_gain_offset[index];
-		pr_debug("%s: listed whole_db_gain:0x%x, adjusted whole_db_gain:0x%x\n",
-			 __func__, comp_dgtl_gain[pa_gain & 0xF].whole_db_gain,
-			 gain_offset->whole_db_gain);
-		gain_offset->half_db_gain = 0;
-	}
-
-	pr_debug("%s: half_db_gain(%d)whole_db_gain(0x%x)comp_gain_offset[%d](%d)\n",
-		 __func__, gain_offset->half_db_gain,
-		 gain_offset->whole_db_gain, index,
-		 sitar->comp_gain_offset[index]);
-	return 0;
+static const char *cf_text[] = {
+	"MIN_3DB_4Hz", "MIN_3DB_75Hz", "MIN_3DB_150Hz"
+};
+
+static const struct soc_enum cf_dec1_enum =
+	SOC_ENUM_SINGLE(SITAR_A_CDC_TX1_MUX_CTL, 4, 3, cf_text);
+
+static const struct soc_enum cf_rxmix1_enum =
+	SOC_ENUM_SINGLE(SITAR_A_CDC_RX1_B4_CTL, 1, 3, cf_text);
+
+static void audio_vol_ramping_func(struct work_struct *work)
+{
+	struct htc_ramp_work *vol_ramp = container_of(work, struct htc_ramp_work, rwork);
+	struct sitar_priv *sitar = container_of(vol_ramp, struct sitar_priv, audio_vol_ramp_work);
+	struct snd_soc_codec *codec = sitar->codec;
+
+	int vol_gain, vol_control, level;
+	int i, index;
+
+	if (!vol_ramp->ramp_type) {
+		vol_gain = vol_ramp->hp_ramp_vol_gain;
+		vol_control = vol_ramp->hp_ramp_vol_control;
+	} else {
+		vol_gain = vol_ramp->line_ramp_vol_gain;
+		vol_control = vol_ramp->line_ramp_vol_control;
 }
+	level = vol_gain - vol_control;
+	index = level > 0 ? level: -level;
 
-static int sitar_config_gain_compander(
-				struct snd_soc_codec *codec,
-				u32 compander, u32 enable, int event)
-{
-	int value = 0;
-	int mask = 1 << 4;
-	struct comp_dgtl_gain_offset gain_offset = {0, 0};
-	if (compander >= COMPANDER_MAX) {
-		pr_err("%s: Error, invalid compander channel\n", __func__);
-		return -EINVAL;
+	if (vol_gain == vol_control){
+		if (!vol_ramp->ramp_type) {
+            pr_info("%s, force volume set without ramping value =%d\n", __func__, vol_control);
+			snd_soc_update_bits(codec, SITAR_A_RX_HPH_L_GAIN, 0x0F,
+					(HPH_RX_GAIN_MAX - vol_control));
+			snd_soc_update_bits(codec, SITAR_A_RX_HPH_R_GAIN, 0x0F,
+					(HPH_RX_GAIN_MAX- vol_control));
+		} else {
+			snd_soc_update_bits(codec, SITAR_A_RX_LINE_1_GAIN, 0x0F,
+					(HPH_RX_GAIN_MAX - vol_control));
+			snd_soc_update_bits(codec, SITAR_A_RX_LINE_2_GAIN, 0x0F,
+					(HPH_RX_GAIN_MAX - vol_control));
+		}
+	return;
 	}
 
-	if ((enable == 0) || SND_SOC_DAPM_EVENT_OFF(event))
-		value = 1 << 4;
+	if (vol_ramp->ramp_type)
+		usleep_range(300000, 300000);
 
-	if (compander == COMPANDER_1) {
-		sitar_compander_gain_offset(codec, enable,
-				SITAR_A_RX_HPH_L_GAIN,
-				SITAR_A_CDC_RX2_VOL_CTL_B2_CTL,
-				mask, event, &gain_offset, 1);
-		snd_soc_update_bits(codec, SITAR_A_RX_HPH_L_GAIN, mask, value);
-		snd_soc_update_bits(codec, SITAR_A_CDC_RX2_VOL_CTL_B2_CTL,
-				    0xFF, gain_offset.whole_db_gain);
-		snd_soc_update_bits(codec, SITAR_A_CDC_RX2_B6_CTL,
-				    0x02, gain_offset.half_db_gain);
-		sitar_compander_gain_offset(codec, enable,
-				SITAR_A_RX_HPH_R_GAIN,
-				SITAR_A_CDC_RX3_VOL_CTL_B2_CTL,
-				mask, event, &gain_offset, 2);
-		snd_soc_update_bits(codec, SITAR_A_RX_HPH_R_GAIN, mask, value);
-		snd_soc_update_bits(codec, SITAR_A_CDC_RX3_VOL_CTL_B2_CTL,
-				    0xFF, gain_offset.whole_db_gain);
-		snd_soc_update_bits(codec, SITAR_A_CDC_RX3_B6_CTL,
-				    0x02, gain_offset.half_db_gain);
-	} else if (compander == COMPANDER_2) {
-		sitar_compander_gain_offset(codec, enable,
-				SITAR_A_RX_LINE_1_GAIN,
-				SITAR_A_CDC_RX1_VOL_CTL_B2_CTL,
-				mask, event, &gain_offset, 0);
-		snd_soc_update_bits(codec, SITAR_A_RX_LINE_1_GAIN, mask, value);
-		snd_soc_update_bits(codec, SITAR_A_RX_LINE_2_GAIN, mask, value);
-		snd_soc_update_bits(codec, SITAR_A_CDC_RX1_VOL_CTL_B2_CTL,
-				    0xFF, gain_offset.whole_db_gain);
-		snd_soc_update_bits(codec, SITAR_A_CDC_RX1_B6_CTL,
-				    0x02, gain_offset.half_db_gain);
+	for (i = 0; i < index; i++) {
+		if (level > 0) {
+			vol_control++;
+			if (!vol_ramp->ramp_type) {
+				snd_soc_update_bits(codec, SITAR_A_RX_HPH_L_GAIN, 0x0F,
+						(HPH_RX_GAIN_MAX - vol_control));
+				snd_soc_update_bits(codec, SITAR_A_RX_HPH_R_GAIN, 0x0F,
+						(HPH_RX_GAIN_MAX- vol_control));
+			} else {
+				snd_soc_update_bits(codec, SITAR_A_RX_LINE_1_GAIN, 0x0F,
+						(HPH_RX_GAIN_MAX - vol_control));
+				snd_soc_update_bits(codec, SITAR_A_RX_LINE_2_GAIN, 0x0F,
+						(HPH_RX_GAIN_MAX - vol_control));
+			}
+			usleep_range(10000, 10000);
+		} else {
+			vol_control--;
+			if (!vol_ramp->ramp_type) {
+				snd_soc_update_bits(codec, SITAR_A_RX_HPH_L_GAIN, 0x0F,
+						(HPH_RX_GAIN_MAX - vol_control));
+				snd_soc_update_bits(codec, SITAR_A_RX_HPH_R_GAIN, 0x0F,
+						(HPH_RX_GAIN_MAX- vol_control));
+			} else {
+				snd_soc_update_bits(codec, SITAR_A_RX_LINE_1_GAIN, 0x0F,
+						(HPH_RX_GAIN_MAX - vol_control));
+				snd_soc_update_bits(codec, SITAR_A_RX_LINE_2_GAIN, 0x0F,
+						(HPH_RX_GAIN_MAX - vol_control));
+			}
+			usleep_range(10000, 10000);
 	}
-	return 0;
 }
 
-static int sitar_get_compander(struct snd_kcontrol *kcontrol,
+	if (!vol_ramp->ramp_type) {
+		vol_ramp->hp_ramp_vol_control = vol_control;
+		pr_info("%s, volume value =%d\n", __func__, vol_ramp->hp_ramp_vol_control);
+	} else {
+		vol_ramp->line_ramp_vol_control = vol_control;
+		pr_info("%s, volume value =%d\n", __func__, vol_ramp->line_ramp_vol_control);
+	}
+	return;
+}
+
+static int sitar_hphr_get_vol_ramp(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int comp = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
+	struct htc_ramp_work *vol_ramp = &sitar->audio_vol_ramp_work;
 
-	ucontrol->value.integer.value[0] = sitar->comp_enabled[comp];
-
+	ucontrol->value.integer.value[0] = vol_ramp->hp_ramp_vol_control;
 	return 0;
 }
 
-static int sitar_set_compander(struct snd_kcontrol *kcontrol,
+static int sitar_hphr_set_vol_ramp(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
-	int comp = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
-	int value = ucontrol->value.integer.value[0];
+	struct htc_ramp_work *vol_ramp = &sitar->audio_vol_ramp_work;
 
-	pr_debug("%s: compander #%d enable %d\n",
-		 __func__, comp + 1, value);
-	if (value == sitar->comp_enabled[comp]) {
-		pr_debug("%s: compander #%d enable %d no change\n",
-			 __func__, comp + 1, value);
-		return 0;
-	}
-	sitar->comp_enabled[comp] = value;
+	pr_info("%s, volume value =%d\n", __func__, vol_ramp->hp_ramp_vol_control);
+	vol_ramp->hp_ramp_vol_gain = ucontrol->value.integer.value[0];
+	vol_ramp->ramp_type = 0;
+	schedule_work(&vol_ramp->rwork);
 	return 0;
 }
 
-static int sitar_config_compander(struct snd_soc_dapm_widget *w,
-				  struct snd_kcontrol *kcontrol,
-				  int event)
+static int sitar_lineout_get_vol_ramp(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = w->codec;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
-	u32 rate = sitar->comp_fs[w->shift];
-	u32 value;
-
-	pr_debug("%s: compander #%d enable %d event %d widget name %s\n",
-		 __func__, w->shift + 1,
-		 sitar->comp_enabled[w->shift], event , w->name);
-	if (sitar->comp_enabled[w->shift] == 0)
-		goto rtn;
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		/* Update compander sample rate */
-		snd_soc_update_bits(codec, SITAR_A_CDC_COMP1_FS_CFG +
-				    w->shift * 8, 0x07, rate);
-		/* Enable compander clock */
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_CLK_RX_B2_CTL,
-				    1 << w->shift,
-				    1 << w->shift);
-		/* Toggle compander reset bits */
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_CLK_OTHR_RESET_CTL,
-				    1 << w->shift,
-				    1 << w->shift);
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_CLK_OTHR_RESET_CTL,
-				    1 << w->shift, 0);
-		sitar_config_gain_compander(codec, w->shift, 1, event);
-		/* Compander enable -> 0x370/0x378 */
-		snd_soc_update_bits(codec, SITAR_A_CDC_COMP1_B1_CTL +
-				    w->shift * 8, 0x03, 0x03);
-		/* Update the RMS meter resampling */
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_COMP1_B3_CTL +
-				    w->shift * 8, 0xFF, 0x01);
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_COMP1_B2_CTL +
-				    w->shift * 8, 0xF0, 0x50);
-		usleep_range(COMP_BRINGUP_WAIT_TIME, COMP_BRINGUP_WAIT_TIME);
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_CLSG_CTL,
-				    0x11, 0x00);
-		if (w->shift == COMPANDER_1)
-			value = 0x22;
-		else
-			value = 0x11;
-		snd_soc_write(codec,
-			      SITAR_A_CDC_CONN_CLSG_CTL, value);
+	struct htc_ramp_work *vol_ramp = &sitar->audio_vol_ramp_work;
 
-		snd_soc_update_bits(codec, SITAR_A_CDC_COMP1_B2_CTL +
-				    w->shift * 8, 0x0F,
-				    comp_samp_params[rate].peak_det_timeout);
-		snd_soc_update_bits(codec, SITAR_A_CDC_COMP1_B2_CTL +
-				    w->shift * 8, 0xF0,
-				    comp_samp_params[rate].rms_meter_div_fact);
-		snd_soc_update_bits(codec, SITAR_A_CDC_COMP1_B3_CTL +
-				w->shift * 8, 0xFF,
-				comp_samp_params[rate].rms_meter_resamp_fact);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec, SITAR_A_CDC_COMP1_B1_CTL +
-				    w->shift * 8, 0x03, 0x00);
-		/* Toggle compander reset bits */
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_CLK_OTHR_RESET_CTL,
-				    1 << w->shift,
-				    1 << w->shift);
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_CLK_OTHR_RESET_CTL,
-				    1 << w->shift, 0);
-		/* Disable compander clock */
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_CLK_RX_B2_CTL,
-				    1 << w->shift,
-				    0);
-		/* Restore the gain */
-		sitar_config_gain_compander(codec, w->shift,
-					    sitar->comp_enabled[w->shift],
-					    event);
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_CLSG_CTL,
-				    0x11, 0x11);
-		snd_soc_write(codec,
-			      SITAR_A_CDC_CONN_CLSG_CTL, 0x14);
-		break;
-	}
-rtn:
+	ucontrol->value.integer.value[0] = vol_ramp->line_ramp_vol_control;
 	return 0;
 }
 
-static int sitar_codec_dem_input_selection(struct snd_soc_dapm_widget *w,
-						struct snd_kcontrol *kcontrol,
-						int event)
+static int sitar_lineout_set_vol_ramp(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = w->codec;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
-	pr_debug("%s: compander#1->enable(%d) compander#2->enable(%d) reg(0x%x = 0x%x) event(%d)\n",
-		__func__, sitar->comp_enabled[COMPANDER_1],
-		sitar->comp_enabled[COMPANDER_2],
-		SITAR_A_CDC_RX1_B6_CTL + w->shift * 8,
-		snd_soc_read(codec, SITAR_A_CDC_RX1_B6_CTL + w->shift * 8),
-		event);
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		if (sitar->comp_enabled[COMPANDER_1] ||
-		    sitar->comp_enabled[COMPANDER_2])
-			snd_soc_update_bits(codec,
-					    SITAR_A_CDC_RX1_B6_CTL +
-					    w->shift * 8,
-					    1 << 5, 0);
-		else
-			snd_soc_update_bits(codec,
-					    SITAR_A_CDC_RX1_B6_CTL +
-					    w->shift * 8,
-					    1 << 5, 0x20);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec,
-				    SITAR_A_CDC_RX1_B6_CTL + w->shift * 8,
-				    1 << 5, 0);
-		break;
-	}
+	struct htc_ramp_work *vol_ramp = &sitar->audio_vol_ramp_work;
+
+	pr_info("%s, volume value =%d\n", __func__, vol_ramp->line_ramp_vol_control);
+	vol_ramp->line_ramp_vol_gain = ucontrol->value.integer.value[0];
+	vol_ramp->ramp_type = 1;
+	schedule_work(&vol_ramp->rwork);
 	return 0;
 }
 
-static const char * const sitar_ear_pa_gain_text[] = {"POS_6_DB",
-					"POS_2_DB", "NEG_2P5_DB", "NEG_12_DB"};
-
-static const struct soc_enum sitar_ear_pa_gain_enum[] = {
-		SOC_ENUM_SINGLE_EXT(4, sitar_ear_pa_gain_text),
-};
-
-/*cut of frequency for high pass filter*/
-static const char *cf_text[] = {
-	"MIN_3DB_4Hz", "MIN_3DB_75Hz", "MIN_3DB_150Hz"
-};
-
-static const struct soc_enum cf_dec1_enum =
-	SOC_ENUM_SINGLE(SITAR_A_CDC_TX1_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_rxmix1_enum =
-	SOC_ENUM_SINGLE(SITAR_A_CDC_RX1_B4_CTL, 1, 3, cf_text);
-
 static const struct snd_kcontrol_new sitar_snd_controls[] = {
 
 	SOC_ENUM_EXT("EAR PA Gain", sitar_ear_pa_gain_enum[0],
@@ -926,6 +663,10 @@
 		line_gain),
 	SOC_SINGLE_TLV("HPHR Volume", SITAR_A_RX_HPH_R_GAIN, 0, 12, 1,
 		line_gain),
+	SOC_SINGLE_EXT_TLV("HPH Ramp Volume", 0, 0, HPH_RX_GAIN_MAX, 1,
+		sitar_hphr_get_vol_ramp, sitar_hphr_set_vol_ramp, line_gain),
+	SOC_SINGLE_EXT_TLV("LINEOUT Ramp Volume", 0, 0, HPH_RX_GAIN_MAX, 1,
+		sitar_lineout_get_vol_ramp, sitar_lineout_set_vol_ramp, line_gain),
 
 	SOC_SINGLE_S8_TLV("RX1 Digital Volume", SITAR_A_CDC_RX1_VOL_CTL_B2_CTL,
 		-84, 40, digital_gain),
@@ -954,7 +695,6 @@
 	SOC_SINGLE_TLV("ADC1 Volume", SITAR_A_TX_1_2_EN, 5, 3, 0, analog_gain),
 	SOC_SINGLE_TLV("ADC2 Volume", SITAR_A_TX_1_2_EN, 1, 3, 0, analog_gain),
 	SOC_SINGLE_TLV("ADC3 Volume", SITAR_A_TX_3_EN, 5, 3, 0, analog_gain),
-
 	SOC_SINGLE_EXT("ANC Slot", SND_SOC_NOPM, 0, 0, 100, sitar_get_anc_slot,
 				   sitar_put_anc_slot),
 
@@ -1007,10 +747,6 @@
 	sitar_get_iir_band_audio_mixer, sitar_put_iir_band_audio_mixer),
 	SOC_SINGLE_MULTI_EXT("IIR2 Band5", IIR2, BAND5, 255, 0, 5,
 	sitar_get_iir_band_audio_mixer, sitar_put_iir_band_audio_mixer),
-	SOC_SINGLE_EXT("COMP1 Switch", SND_SOC_NOPM, COMPANDER_1, 1, 0,
-				sitar_get_compander, sitar_set_compander),
-	SOC_SINGLE_EXT("COMP2 Switch", SND_SOC_NOPM, COMPANDER_2, 1, 0,
-				sitar_get_compander, sitar_set_compander),
 };
 
 static const char *rx_mix1_text[] = {
@@ -1204,7 +940,6 @@
 
 static const struct snd_kcontrol_new sb_tx1_mux =
 	SOC_DAPM_ENUM("SLIM TX1 MUX Mux", sb_tx1_mux_enum);
-
 static int wcd9304_put_dec_enum(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 	{
@@ -1219,6 +954,7 @@
 	u16 tx_mux_ctl_reg;
 	u8 adc_dmic_sel = 0x0;
 	int ret = 0;
+	char *str = NULL;
 
 	if (ucontrol->value.enumerated.item[0] > e->max - 1)
 		return -EINVAL;
@@ -1238,38 +974,39 @@
 		goto out;
 	}
 
-	ret = kstrtouint(strpbrk(dec_name, "1234"), 10, &decimator);
+        ret = -1;
+        str = strpbrk(dec_name, "123456789");
+        if (str)
+	  ret = kstrtouint(str, 10, &decimator);
 	if (ret < 0) {
 		pr_err("%s: Invalid decimator = %s\n", __func__, dec_name);
 		ret = -EINVAL;
 		goto out;
 	}
 
-	dev_dbg(w->dapm->dev, "%s(): widget = %s dec_name = %s decimator = %u"\
+	dev_dbg(w->dapm->dev, "%s(): widget = %s dec_name = %s decimator = %u"
 		"dec_mux = %u\n", __func__, w->name, dec_name, decimator,
 		dec_mux);
 
-
 	switch (decimator) {
 	case 1:
 	case 2:
 		if ((dec_mux == 1) || (dec_mux == 6))
-			adc_dmic_sel = ADC_DMIC_SEL_DMIC;
+			adc_dmic_sel = 0x1;
 		else
-			adc_dmic_sel = ADC_DMIC_SEL_ADC;
+			adc_dmic_sel = 0x0;
 		break;
 	case 3:
 		if ((dec_mux == 1) || (dec_mux == 6) || (dec_mux == 7))
-			adc_dmic_sel = ADC_DMIC_SEL_DMIC;
+			adc_dmic_sel = 0x1;
 		else
-			adc_dmic_sel = ADC_DMIC_SEL_ADC;
+			adc_dmic_sel = 0x0;
 		break;
 	case 4:
-		if ((dec_mux == 1) || (dec_mux == 5)
-			|| (dec_mux == 6) || (dec_mux == 7))
-			adc_dmic_sel = ADC_DMIC_SEL_DMIC;
+		if ((dec_mux == 1) ||(dec_mux == 5) || (dec_mux == 6) || (dec_mux == 7))
+			adc_dmic_sel = 0x1;
 		else
-			adc_dmic_sel = ADC_DMIC_SEL_ADC;
+			adc_dmic_sel = 0x0;
 		break;
 	default:
 		pr_err("%s: Invalid Decimator = %u\n", __func__, decimator);
@@ -1305,7 +1042,6 @@
 
 static const struct snd_kcontrol_new dec4_mux =
 	WCD9304_DEC_ENUM("DEC4 MUX Mux", dec4_mux_enum);
-
 static const struct snd_kcontrol_new iir1_inp1_mux =
 	SOC_DAPM_ENUM("IIR1 INP1 Mux", iir1_inp1_mux_enum);
 
@@ -1334,8 +1070,7 @@
 
 	if (enable) {
 		sitar->adc_count++;
-		snd_soc_update_bits(codec, SITAR_A_CDC_CLK_OTHR_CTL,
-				0x02, 0x02);
+		snd_soc_update_bits(codec, SITAR_A_CDC_CLK_OTHR_CTL, 0x02, 0x02);
 	} else {
 		sitar->adc_count--;
 		if (!sitar->adc_count) {
@@ -1411,58 +1146,18 @@
 	return 0;
 }
 
-static void sitar_enable_classg(struct snd_soc_codec *codec,
-	bool enable)
-{
-
-	if (enable) {
-		snd_soc_update_bits(codec,
-			SITAR_A_CDC_CLK_OTHR_RESET_CTL, 0x10, 0x00);
-		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x07, 0x00);
-		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x08, 0x00);
-		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x10, 0x00);
-
-	} else {
-		snd_soc_update_bits(codec,
-			SITAR_A_CDC_CLK_OTHR_RESET_CTL, 0x10, 0x10);
-		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x07, 0x03);
-		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x08, 0x08);
-		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x10, 0x10);
-	}
-}
-
-static bool sitar_is_hph_pa_on(struct snd_soc_codec *codec)
-{
-	u8 hph_reg_val = 0;
-	hph_reg_val = snd_soc_read(codec, SITAR_A_RX_HPH_CNP_EN);
-
-	return (hph_reg_val & 0x30) ? true : false;
-}
-
-static bool sitar_is_line_pa_on(struct snd_soc_codec *codec)
-{
-	u8 line_reg_val = 0;
-	line_reg_val = snd_soc_read(codec, SITAR_A_RX_LINE_CNP_EN);
-
-	return (line_reg_val & 0x03) ? true : false;
-}
-
 static int sitar_codec_enable_lineout(struct snd_soc_dapm_widget *w,
 		struct snd_kcontrol *kcontrol, int event)
 {
 	struct snd_soc_codec *codec = w->codec;
-	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
 	u16 lineout_gain_reg;
 
-	pr_debug("%s %d %s comp2 enable %d\n", __func__, event, w->name,
-		 sitar->comp_enabled[COMPANDER_2]);
-
-	if (sitar->comp_enabled[COMPANDER_2])
-		goto rtn;
+	pr_debug("%s %d %s\n", __func__, event, w->name);
 
 	switch (w->shift) {
 	case 0:
 		lineout_gain_reg = SITAR_A_RX_LINE_1_GAIN;
+		usleep_range(100000, 100000);
 		break;
 	case 1:
 		lineout_gain_reg = SITAR_A_RX_LINE_2_GAIN;
@@ -1475,15 +1170,6 @@
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
-		if (sitar_is_hph_pa_on(codec)) {
-			snd_soc_update_bits(codec, SITAR_A_CDC_RX1_B6_CTL,
-				0x20, 0x00);
-			sitar_enable_classg(codec, false);
-		} else {
-			snd_soc_update_bits(codec, SITAR_A_CDC_RX1_B6_CTL,
-				0x20, 0x20);
-			sitar_enable_classg(codec, true);
-		}
 		snd_soc_update_bits(codec, lineout_gain_reg, 0x10, 0x10);
 		break;
 	case SND_SOC_DAPM_POST_PMU:
@@ -1492,15 +1178,9 @@
 		usleep_range(16000, 16000);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
-		if (sitar_is_hph_pa_on(codec))
-			sitar_enable_classg(codec, true);
-		else
-			sitar_enable_classg(codec, false);
-
 		snd_soc_update_bits(codec, lineout_gain_reg, 0x10, 0x00);
 		break;
 	}
-rtn:
 	return 0;
 }
 
@@ -1511,7 +1191,7 @@
 	u16 tx_dmic_ctl_reg;
 	u8 dmic_clk_sel, dmic_clk_en;
 	unsigned int dmic;
-	int ret;
+	int ret= -1;
 
 	ret = kstrtouint(strpbrk(w->name, "1234"), 10, &dmic);
 	if (ret < 0) {
@@ -1537,7 +1217,6 @@
 		pr_err("%s: Invalid DMIC Selection\n", __func__);
 		return -EINVAL;
 	}
-
 	tx_dmic_ctl_reg = SITAR_A_CDC_TX1_DMIC_CTL + 8 * (dmic - 1);
 
 	pr_debug("%s %d\n", __func__, event);
@@ -1581,10 +1260,6 @@
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 
-		/* Use the same firmware file as that of WCD9310,
-		 * since the register sequences are same for
-		 * WCD9310 and WCD9304
-		 */
 		filename = "wcd9310/wcd9310_anc.bin";
 
 		ret = request_firmware(&fw, filename, codec->dev);
@@ -1594,13 +1269,18 @@
 			return -ENODEV;
 		}
 
-		if (fw->size < sizeof(struct anc_header)) {
+		if (fw == NULL) {
+			dev_err(codec->dev, "Access NULL pointer: fw\n");
+			return -EINVAL;
+		}
+
+		if (!fw || (fw->size < sizeof(struct anc_header))) {
 			dev_err(codec->dev, "Not enough data\n");
 			release_firmware(fw);
 			return -ENOMEM;
 		}
 
-		/* First number is the number of register writes */
+		
 		anc_head = (struct anc_header *)(fw->data);
 		anc_ptr = (u32 *)((u32)fw->data + sizeof(struct anc_header));
 		anc_size_remaining = fw->size - sizeof(struct anc_header);
@@ -1653,9 +1333,6 @@
 
 		release_firmware(fw);
 
-		/* For Sitar, it is required to enable both Feed-forward
-		 * and Feed back clocks to enable ANC
-		 */
 		snd_soc_write(codec, SITAR_A_CDC_CLK_ANC_CLK_EN_CTL, 0x0F);
 
 		break;
@@ -1686,7 +1363,7 @@
 		if (mbhc_state == MBHC_STATE_POTENTIAL) {
 			pr_debug("%s recovering MBHC state macine\n", __func__);
 			sitar->mbhc_state = MBHC_STATE_POTENTIAL_RECOVERY;
-			/* set to max button press threshold */
+			
 			snd_soc_write(codec, SITAR_A_CDC_MBHC_VOLT_B2_CTL,
 				      0x7F);
 			snd_soc_write(codec, SITAR_A_CDC_MBHC_VOLT_B1_CTL,
@@ -1695,7 +1372,7 @@
 				       0x7F);
 			snd_soc_write(codec, SITAR_A_CDC_MBHC_VOLT_B3_CTL,
 				      0xFF);
-			/* set to max */
+			
 			snd_soc_write(codec, SITAR_A_CDC_MBHC_VOLT_B6_CTL,
 				      0x7F);
 			snd_soc_write(codec, SITAR_A_CDC_MBHC_VOLT_B5_CTL,
@@ -1775,25 +1452,22 @@
 		micb_cfilt_reg = SITAR_A_MICB_CFILT_2_CTL;
 		break;
 	default:
-		return; /* should not happen */
+		return; 
 	}
 
 	if (inc) {
 		if (!(*cfilt_cnt_ptr)++) {
-			/* Switch CFILT to slow mode if MBHC CFILT being used */
+			
 			if (cfilt_sel == sitar->mbhc_bias_regs.cfilt_sel)
 				sitar_codec_switch_cfilt_mode(codec, 0);
 
 			snd_soc_update_bits(codec, micb_cfilt_reg, 0x80, 0x80);
 		}
 	} else {
-		/* check if count not zero, decrement
-		* then check if zero, go ahead disable cfilter
-		*/
 		if ((*cfilt_cnt_ptr) && !--(*cfilt_cnt_ptr)) {
 			snd_soc_update_bits(codec, micb_cfilt_reg, 0x80, 0);
 
-			/* Switch CFILT to fast mode if MBHC CFILT being used */
+			
 			if (cfilt_sel == sitar->mbhc_bias_regs.cfilt_sel)
 				sitar_codec_switch_cfilt_mode(codec, 1);
 		}
@@ -1840,6 +1514,14 @@
 	return rc;
 }
 
+static bool sitar_is_hph_pa_on(struct snd_soc_codec *codec)
+{
+	u8 hph_reg_val = 0;
+	hph_reg_val = snd_soc_read(codec, SITAR_A_RX_HPH_CNP_EN);
+
+	return (hph_reg_val & 0x30) ? true : false;
+}
+
 static bool sitar_is_hph_dac_on(struct snd_soc_codec *codec, int left)
 {
 	u8 hph_reg_val = 0;
@@ -1866,7 +1548,7 @@
 			sitar->mbhc_polling_active) {
 
 			sitar_codec_pause_hs_polling(codec);
-			/* Enable Mic Bias switch to VDDIO */
+			
 			sitar->cfilt_k_value = snd_soc_read(codec,
 					sitar->mbhc_bias_regs.cfilt_val);
 			cfilt_k_val = sitar_find_k_value(
@@ -1893,7 +1575,7 @@
 				sitar_codec_pause_hs_polling(codec);
 				mbhc_was_polling = true;
 			}
-			/* Disable Mic Bias switch to VDDIO */
+			
 			if (sitar->cfilt_k_value != 0)
 				snd_soc_update_bits(codec,
 					sitar->mbhc_bias_regs.cfilt_val, 0XFC,
@@ -1944,14 +1626,13 @@
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
-		/* Decide whether to switch the micbias for MBHC */
+		
 		if (w->reg == sitar->mbhc_bias_regs.ctl_reg) {
 			SITAR_ACQUIRE_LOCK(sitar->codec_resource_lock);
 			sitar_codec_switch_micbias(codec, 0);
 			SITAR_RELEASE_LOCK(sitar->codec_resource_lock);
 		}
-
-		snd_soc_update_bits(codec, w->reg, 0x1E, 0x00);
+		snd_soc_update_bits(codec, w->reg, 0x0E, 0x0A);
 		sitar_codec_update_cfilt_usage(codec, cfilt_sel_val, 1);
 
 		if (strnstr(w->name, internal1_text, 30))
@@ -1960,8 +1641,6 @@
 			snd_soc_update_bits(codec, micb_int_reg, 0x1C, 0x1C);
 		break;
 	case SND_SOC_DAPM_POST_PMU:
-
-		usleep_range(20000, 20000);
 		if (sitar->mbhc_polling_active &&
 		    sitar->mbhc_cfg.micbias == micb_line) {
 			SITAR_ACQUIRE_LOCK(sitar->codec_resource_lock);
@@ -1987,141 +1666,37 @@
 	return 0;
 }
 
-static void tx_hpf_corner_freq_callback(struct work_struct *work)
-{
-	struct delayed_work *hpf_delayed_work;
-	struct hpf_work *hpf_work;
-	struct sitar_priv *sitar;
-	struct snd_soc_codec *codec;
-	u16 tx_mux_ctl_reg;
-	u8 hpf_cut_of_freq;
-
-	hpf_delayed_work = to_delayed_work(work);
-	hpf_work = container_of(hpf_delayed_work, struct hpf_work, dwork);
-	sitar = hpf_work->sitar;
-	codec = hpf_work->sitar->codec;
-	hpf_cut_of_freq = hpf_work->tx_hpf_cut_of_freq;
-
-	tx_mux_ctl_reg = SITAR_A_CDC_TX1_MUX_CTL +
-				(hpf_work->decimator - 1) * 8;
-
-	pr_debug("%s(): decimator %u hpf_cut_of_freq 0x%x\n", __func__,
-			hpf_work->decimator, (unsigned int)hpf_cut_of_freq);
-
-	snd_soc_update_bits(codec, tx_mux_ctl_reg,
-			CUT_OF_FREQ_MASK, hpf_cut_of_freq << 4);
-}
-
 static int sitar_codec_enable_dec(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
 	struct snd_soc_codec *codec = w->codec;
-	u16 dec_reset_reg, gain_reg, tx_vol_ctl_reg, tx_mux_ctl_reg;
-	unsigned int decimator;
-	char *dec_name = NULL;
-	char *widget_name = NULL;
-	char *temp;
-	int ret = 0;
-	u8 dec_hpf_cut_of_freq, current_gain;
+	u16 dec_reset_reg, gain_reg;
+	u8 current_gain;
 
 	pr_debug("%s %d\n", __func__, event);
 
-	widget_name = kstrndup(w->name, 15, GFP_KERNEL);
-	if (!widget_name)
-		return -ENOMEM;
-	temp = widget_name;
-
-	dec_name = strsep(&widget_name, " ");
-	widget_name = temp;
-	if (!dec_name) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, w->name);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	ret = kstrtouint(strpbrk(dec_name, "1234"), 10, &decimator);
-	if (ret < 0) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, dec_name);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	pr_debug("%s(): widget = %s dec_name = %s decimator = %u\n", __func__,
-		w->name, dec_name, decimator);
-
 	if (w->reg == SITAR_A_CDC_CLK_TX_CLK_EN_B1_CTL)
 		dec_reset_reg = SITAR_A_CDC_CLK_TX_RESET_B1_CTL;
 	else {
 		pr_err("%s: Error, incorrect dec\n", __func__);
-		ret = EINVAL;
-		goto out;
+		return -EINVAL;
 	}
 
-	tx_vol_ctl_reg = SITAR_A_CDC_TX1_VOL_CTL_CFG + 8 * (decimator - 1);
-	tx_mux_ctl_reg = SITAR_A_CDC_TX1_MUX_CTL + 8 * (decimator - 1);
-
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
-		/* Enable TX Digital Mute */
-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x01);
-
 		snd_soc_update_bits(codec, dec_reset_reg, 1 << w->shift,
 			1 << w->shift);
 		snd_soc_update_bits(codec, dec_reset_reg, 1 << w->shift, 0x0);
-
-		dec_hpf_cut_of_freq = snd_soc_read(codec, tx_mux_ctl_reg);
-		dec_hpf_cut_of_freq = (dec_hpf_cut_of_freq &
-						CUT_OF_FREQ_MASK) >> 4;
-
-		tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq =
-						dec_hpf_cut_of_freq;
-
-		if ((dec_hpf_cut_of_freq != CF_MIN_3DB_150HZ)) {
-			/* Set cut off freq to CF_MIN_3DB_150HZ (0x01) */
-			snd_soc_update_bits(codec, tx_mux_ctl_reg,
-				CUT_OF_FREQ_MASK, CF_MIN_3DB_150HZ << 4);
-		}
-
-		/* enable HPF */
-		snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x08, 0x00);
-
+		snd_soc_update_bits(codec, SITAR_A_CDC_CLK_TX_CLK_EN_B1_CTL, 0x01, 0x01);
 		break;
-
 	case SND_SOC_DAPM_POST_PMU:
-		/* Disable TX Digital Mute */
-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x00);
-
-		if (tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq !=
-				CF_MIN_3DB_150HZ) {
-			schedule_delayed_work(&tx_hpf_work[decimator - 1].dwork,
-				msecs_to_jiffies(300));
-		}
 
-		/* Reprogram the digital gain after power up of Decimator */
 		gain_reg = SITAR_A_CDC_TX1_VOL_CTL_GAIN + (8 * w->shift);
 		current_gain = snd_soc_read(codec, gain_reg);
 		snd_soc_write(codec, gain_reg, current_gain);
 		break;
-
-	case SND_SOC_DAPM_PRE_PMD:
-		/* Enable Digital Mute, Cancel possibly scheduled work */
-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x01);
-		cancel_delayed_work_sync(&tx_hpf_work[decimator - 1].dwork);
-
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x08, 0x08);
-		snd_soc_update_bits(codec, tx_mux_ctl_reg, CUT_OF_FREQ_MASK,
-			(tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq) << 4);
-		break;
-
 	}
-
-out:
-	kfree(widget_name);
-	return ret;
-
+	return 0;
 }
 
 static int sitar_codec_reset_interpolator(struct snd_soc_dapm_widget *w,
@@ -2141,7 +1716,7 @@
 			1 << w->shift, 0x0);
 		break;
 	case SND_SOC_DAPM_POST_PMU:
-		/* Reprogram gain after power up interpolator */
+		
 		gain_reg = SITAR_A_CDC_RX1_VOL_CTL_B2_CTL + (8 * w->shift);
 		current_gain = snd_soc_read(codec, gain_reg);
 		snd_soc_write(codec, gain_reg, current_gain);
@@ -2200,23 +1775,17 @@
 	struct snd_kcontrol *kcontrol, int event)
 {
 	struct snd_soc_codec *codec = w->codec;
-	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
 
-	pr_debug("%s %s %d comp#1 enable %d\n", __func__,
-		 w->name, event, sitar->comp_enabled[COMPANDER_1]);
+	pr_debug("%s %s %d\n", __func__, w->name, event);
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 		if (w->reg == SITAR_A_RX_HPH_L_DAC_CTL) {
-			if (!sitar->comp_enabled[COMPANDER_1]) {
-				snd_soc_update_bits(codec,
-						    SITAR_A_CDC_CONN_CLSG_CTL,
+			snd_soc_update_bits(codec, SITAR_A_CDC_CONN_CLSG_CTL,
 						    0x30, 0x20);
-				snd_soc_update_bits(codec,
-						    SITAR_A_CDC_CONN_CLSG_CTL,
+			snd_soc_update_bits(codec, SITAR_A_CDC_CONN_CLSG_CTL,
 						    0x0C, 0x08);
 			}
-		}
 		snd_soc_update_bits(codec, w->reg, 0x40, 0x40);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
@@ -2236,8 +1805,8 @@
 				     struct snd_soc_jack *jack, int status,
 				     int mask)
 {
-	/* XXX: wake_lock_timeout()? */
-	snd_soc_jack_report_no_dapm(jack, status, mask);
+	
+	snd_soc_jack_report(jack, status, mask);
 }
 
 static void hphocp_off_report(struct sitar_priv *sitar,
@@ -2261,9 +1830,6 @@
 						SITAR_JACK_MASK);
 		snd_soc_update_bits(codec, SITAR_A_RX_HPH_OCP_CTL, 0x10, 0x00);
 		snd_soc_update_bits(codec, SITAR_A_RX_HPH_OCP_CTL, 0x10, 0x10);
-		/* reset retry counter as PA is turned off signifying
-		* start of new OCP detection session
-		*/
 		if (SITAR_IRQ_HPH_PA_OCPL_FAULT)
 			sitar->hphlocp_cnt = 0;
 		else
@@ -2305,19 +1871,10 @@
 			SITAR_RELEASE_LOCK(sitar->codec_resource_lock);
 		}
 
-		if (sitar_is_line_pa_on(codec))
-			sitar_enable_classg(codec, false);
-		else
-			sitar_enable_classg(codec, true);
-
 		break;
 
 	case SND_SOC_DAPM_POST_PMD:
-		/* schedule work is required because at the time HPH PA DAPM
-		* event callback is called by DAPM framework, CODEC dapm mutex
-		* would have been locked while snd_soc_jack_report also
-		* attempts to acquire same lock.
-		*/
+		usleep_range(15000,15000);
 		if (w->shift == 5) {
 			clear_bit(SITAR_HPHL_PA_OFF_ACK,
 				 &sitar->hph_pa_dac_state);
@@ -2342,11 +1899,6 @@
 				w->name);
 		usleep_range(10000, 10000);
 
-		if (sitar_is_line_pa_on(codec))
-			sitar_enable_classg(codec, true);
-		else
-			sitar_enable_classg(codec, false);
-
 		break;
 	}
 	return 0;
@@ -2372,7 +1924,7 @@
 		micbias_regs->ctl_reg = SITAR_A_MICB_2_CTL;
 		break;
 	default:
-		/* Should never reach here */
+		
 		pr_err("%s: Invalid MIC BIAS for MBHC\n", __func__);
 		return;
 	}
@@ -2401,21 +1953,36 @@
 	pr_debug("%s %d\n", __func__, event);
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, SITAR_A_CDC_CLK_OTHR_RESET_CTL, 0x10,
+			0x00);
 		snd_soc_update_bits(codec, SITAR_A_CDC_CLK_OTHR_CTL, 0x01,
 			0x01);
 		snd_soc_update_bits(codec, SITAR_A_CDC_CLSG_CTL, 0x08, 0x08);
 		usleep_range(200, 200);
+		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x10, 0x00);
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
-		snd_soc_update_bits(codec, SITAR_A_CDC_CLSG_CTL, 0x08, 0x00);
-		/*
-		 * This delay is for the class G controller to settle down
-		 * after turn OFF. The delay is as per the hardware spec for
-		 * the codec
-		 */
+		snd_soc_update_bits(codec, SITAR_A_CDC_CLK_OTHR_RESET_CTL, 0x10,
+			0x10);
 		usleep_range(20, 20);
+		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x08, 0x08);
+		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x10, 0x10);
+		snd_soc_update_bits(codec, SITAR_A_CDC_CLSG_CTL, 0x08, 0x00);
 		snd_soc_update_bits(codec, SITAR_A_CDC_CLK_OTHR_CTL, 0x01,
 			0x00);
+		snd_soc_update_bits(codec, SITAR_A_CP_STATIC, 0x08, 0x00);
+		break;
+	}
+	return 0;
+}
+
+static int sitar_ear_dac_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	pr_debug("%s: event = %d\n", __func__, event);
+	switch (event) {
+		case SND_SOC_DAPM_PRE_PMU:
+			usleep_range(10000,10000);
 		break;
 	}
 	return 0;
@@ -2447,14 +2014,14 @@
 };
 
 static const struct snd_soc_dapm_widget sitar_dapm_widgets[] = {
-	/*RX stuff */
+	
 	SND_SOC_DAPM_OUTPUT("EAR"),
 
 	SND_SOC_DAPM_PGA_E("EAR PA", SITAR_A_RX_EAR_EN, 4, 0, NULL, 0,
 				sitar_ear_pa_event, SND_SOC_DAPM_POST_PMU |
 				SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MIXER("DAC1", SITAR_A_RX_EAR_EN, 6, 0, dac1_switch,
-		ARRAY_SIZE(dac1_switch)),
+	SND_SOC_DAPM_MIXER_E("DAC1", SITAR_A_RX_EAR_EN, 6, 0, dac1_switch,
+		ARRAY_SIZE(dac1_switch), sitar_ear_dac_event, SND_SOC_DAPM_PRE_PMU),
 	SND_SOC_DAPM_SUPPLY("EAR DRIVER", SITAR_A_RX_EAR_EN, 3, 0, NULL, 0),
 	SND_SOC_DAPM_AIF_IN_E("SLIM RX1", "AIF1 Playback", 0, SND_SOC_NOPM, 0,
 				0, sitar_codec_enable_slimrx,
@@ -2466,7 +2033,7 @@
 	SND_SOC_DAPM_AIF_IN("SLIM RX4", "AIF1 Playback", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_IN("SLIM RX5", "AIF1 Playback", 0, SND_SOC_NOPM, 0, 0),
 
-	/* Headphone */
+	
 	SND_SOC_DAPM_OUTPUT("HEADPHONE"),
 	SND_SOC_DAPM_PGA_E("HPHL", SITAR_A_RX_HPH_CNP_EN, 5, 0, NULL, 0,
 		sitar_hph_pa_event, SND_SOC_DAPM_PRE_PMU |
@@ -2483,7 +2050,7 @@
 		sitar_hph_dac_event,
 		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
 
-	/* Speaker */
+	
 	SND_SOC_DAPM_OUTPUT("LINEOUT1"),
 	SND_SOC_DAPM_OUTPUT("LINEOUT2"),
 
@@ -2520,15 +2087,9 @@
 	SND_SOC_DAPM_MUX("DAC4 MUX", SND_SOC_NOPM, 0, 0,
 		&rx_dac4_mux),
 
-	SND_SOC_DAPM_MIXER_E("RX1 CHAIN", SND_SOC_NOPM, 0, 0, NULL,
-		0, sitar_codec_dem_input_selection,
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-	SND_SOC_DAPM_MIXER_E("RX2 CHAIN", SND_SOC_NOPM, 1, 0, NULL,
-		0, sitar_codec_dem_input_selection,
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-	SND_SOC_DAPM_MIXER_E("RX3 CHAIN", SND_SOC_NOPM, 2, 0, NULL,
-		0, sitar_codec_dem_input_selection,
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+	SND_SOC_DAPM_MIXER("RX1 CHAIN", SITAR_A_CDC_RX1_B6_CTL, 5, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER("RX2 CHAIN", SITAR_A_CDC_RX2_B6_CTL, 5, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER("RX3 CHAIN", SITAR_A_CDC_RX3_B6_CTL, 5, 0, NULL, 0),
 
 	SND_SOC_DAPM_MUX("RX1 MIX1 INP1", SND_SOC_NOPM, 0, 0,
 		&rx_mix1_inp1_mux),
@@ -2552,7 +2113,7 @@
 
 	SND_SOC_DAPM_SUPPLY("LDO_H", SITAR_A_LDO_H_MODE_1, 7, 0,
 		sitar_codec_enable_ldo_h, SND_SOC_DAPM_POST_PMU),
-	/* TX */
+	
 
 	SND_SOC_DAPM_SUPPLY("CDC_CONN", SITAR_A_CDC_CLK_OTHR_CTL, 2, 0, NULL,
 		0),
@@ -2588,23 +2149,16 @@
 
 	SND_SOC_DAPM_MUX_E("DEC1 MUX", SITAR_A_CDC_CLK_TX_CLK_EN_B1_CTL, 0, 0,
 		&dec1_mux, sitar_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
+		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_MUX_E("DEC2 MUX", SITAR_A_CDC_CLK_TX_CLK_EN_B1_CTL, 1, 0,
 		&dec2_mux, sitar_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
+		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_MUX_E("DEC3 MUX", SITAR_A_CDC_CLK_TX_CLK_EN_B1_CTL, 2, 0,
 		&dec3_mux, sitar_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
+		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_MUX_E("DEC4 MUX", SITAR_A_CDC_CLK_TX_CLK_EN_B1_CTL, 3, 0,
 		&dec4_mux, sitar_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
 
 	SND_SOC_DAPM_MUX("ANC1 MUX", SND_SOC_NOPM, 0, 0, &anc1_mux),
 	SND_SOC_DAPM_MUX("ANC2 MUX", SND_SOC_NOPM, 0, 0, &anc2_mux),
@@ -2640,7 +2194,7 @@
 				0, sitar_codec_enable_slimtx,
 				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
 
-	/* Digital Mic Inputs */
+	
 	SND_SOC_DAPM_ADC_E("DMIC1", NULL, SND_SOC_NOPM, 0, 0,
 		sitar_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
 		SND_SOC_DAPM_POST_PMD),
@@ -2654,14 +2208,7 @@
 		sitar_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
 		SND_SOC_DAPM_POST_PMD),
 
-	SND_SOC_DAPM_SUPPLY("COMP1_CLK", SND_SOC_NOPM, COMPANDER_1, 0,
-		sitar_config_compander, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_SUPPLY("COMP2_CLK", SND_SOC_NOPM, COMPANDER_2, 0,
-		sitar_config_compander, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
 
-	/* Sidetone */
 	SND_SOC_DAPM_MUX("IIR1 INP1 MUX", SND_SOC_NOPM, 0, 0, &iir1_inp1_mux),
 	SND_SOC_DAPM_PGA("IIR1", SITAR_A_CDC_CLK_SD_CTL, 0, 0, NULL, 0),
 	SND_SOC_DAPM_MUX("IIR2 INP1 MUX", SND_SOC_NOPM, 0, 0, &iir2_inp1_mux),
@@ -2684,7 +2231,7 @@
 };
 
 static const struct snd_soc_dapm_route audio_map[] = {
-	/* Earpiece (RX MIX1) */
+	
 	{"EAR", NULL, "EAR PA"},
 	{"EAR PA", "NULL", "DAC1"},
 	{"DAC1", "Switch", "DAC1 MUX"},
@@ -2711,11 +2258,10 @@
 	{"ANC", NULL, "ANC1 FB MUX"},
 
 
-	/* Headset (RX MIX1 and RX MIX2) */
+	
 	{"HEADPHONE", NULL, "HPHL"},
 	{"HEADPHONE", NULL, "HPHR"},
 
-
 	{"HPHL DAC", NULL, "CP"},
 	{"HPHR DAC", NULL, "CP"},
 
@@ -2744,7 +2290,7 @@
 	{"RX3 MIX1", NULL, "RX3 MIX1 INP1"},
 	{"RX3 MIX1", NULL, "RX3 MIX1 INP2"},
 
-	/* ANC */
+	
 	{"ANC", NULL, "ANC1 MUX"},
 	{"ANC", NULL, "ANC2 MUX"},
 	{"ANC1 MUX", "ADC1", "ADC1"},
@@ -2759,11 +2305,9 @@
 	{"RX2 MIX1", NULL, "ANC"},
 	{"RX3 MIX1", NULL, "ANC"},
 
-	{"RX1 MIX1", NULL, "COMP2_CLK"},
-	{"RX2 MIX1", NULL, "COMP1_CLK"},
-	{"RX3 MIX1", NULL, "COMP1_CLK"},
 
-	/* Slimbus port 5 is non functional in Sitar 1.0 */
+
+	
 	{"RX1 MIX1 INP1", "RX1", "SLIM RX1"},
 	{"RX1 MIX1 INP1", "RX2", "SLIM RX2"},
 	{"RX1 MIX1 INP1", "RX3", "SLIM RX3"},
@@ -2802,7 +2346,7 @@
 	{"RX3 MIX1 INP2", "IIR2", "IIR2"},
 
 
-	/* TX */
+	
 	{"SLIM TX1", NULL, "SLIM TX1 MUX"},
 	{"SLIM TX2", NULL, "SLIM TX2 MUX"},
 	{"SLIM TX3", NULL, "SLIM TX3 MUX"},
@@ -2812,13 +2356,15 @@
 	{"SLIM TX1 MUX", "DEC1", "DEC1 MUX"},
 	{"SLIM TX2 MUX", "DEC2", "DEC2 MUX"},
 	{"SLIM TX3 MUX", "DEC3", "DEC3 MUX"},
+	{"SLIM TX3 MUX", "RMIX1", "RX1 MIX1"}, 
+	{"SLIM TX3 MUX", "RMIX2", "RX2 MIX1"}, 
 	{"SLIM TX4 MUX", "DEC4", "DEC4 MUX"},
 	{"SLIM TX5 MUX", "DEC1", "DEC1 MUX"},
 	{"SLIM TX5 MUX", "DEC2", "DEC2 MUX"},
 	{"SLIM TX5 MUX", "DEC3", "DEC3 MUX"},
 	{"SLIM TX5 MUX", "DEC4", "DEC4 MUX"},
 
-	/* Decimator Inputs */
+	
 	{"DEC1 MUX", "DMIC1", "DMIC1"},
 	{"DEC1 MUX", "DMIC4", "DMIC4"},
 	{"DEC1 MUX", "ADC1", "ADC1"},
@@ -2847,12 +2393,12 @@
 	{"DEC4 MUX", "DMIC1", "DMIC1"},
 	{"DEC4 MUX", NULL, "CDC_CONN"},
 
-	/* ADC Connections */
+	
 	{"ADC1", NULL, "AMIC1"},
 	{"ADC2", NULL, "AMIC2"},
 	{"ADC3", NULL, "AMIC3"},
 
-	/* IIR */
+	
 	{"IIR1", NULL, "IIR1 INP1 MUX"},
 	{"IIR1 INP1 MUX", "DEC1", "DEC1 MUX"},
 	{"IIR1 INP1 MUX", "DEC2", "DEC2 MUX"},
@@ -2896,7 +2442,7 @@
 	if ((reg >= SITAR_A_CDC_MBHC_EN_CTL) || (reg < 0x100))
 		return 1;
 
-	/* IIR Coeff registers are not cacheable */
+	
 	if ((reg >= SITAR_A_CDC_IIR1_COEF_B1_CTL) &&
 		(reg <= SITAR_A_CDC_IIR1_COEF_B5_CTL))
 		return 1;
@@ -2910,14 +2456,10 @@
 		if (reg == SITAR_A_CDC_RX1_VOL_CTL_B2_CTL + (8 * i))
 			return 1;
 	}
-
-	if ((reg == SITAR_A_CDC_COMP1_SHUT_DOWN_STATUS) ||
-		(reg == SITAR_A_CDC_COMP2_SHUT_DOWN_STATUS))
-			return 1;
 	return 0;
 }
 
-#define SITAR_FORMATS (SNDRV_PCM_FMTBIT_S16_LE)
+#define SITAR_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FORMAT_S24_LE)
 static int sitar_write(struct snd_soc_codec *codec, unsigned int reg,
 	unsigned int value)
 {
@@ -2983,9 +2525,6 @@
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
 	struct wcd9xxx *sitar_core = dev_get_drvdata(codec->dev->parent);
 
-	/* TODO lock resources accessed by audio streams and threaded
-	* interrupt handlers
-	*/
 
 	pr_debug("%s, choice is %d, current is %d\n", __func__, choice,
 		sitar->bandgap_type);
@@ -2997,12 +2536,6 @@
 		(choice == SITAR_BANDGAP_AUDIO_MODE)) {
 		sitar_codec_enable_audio_mode_bandgap(codec);
 	} else if (choice == SITAR_BANDGAP_MBHC_MODE) {
-		/*
-		 * bandgap mode becomes fast,
-		 * mclk should be off or clk buff source shouldn't be VBG
-		 * Let's turn off mclk always
-		 */
-		WARN_ON(snd_soc_read(codec, SITAR_A_CLK_BUFF_EN2) & (1 << 2));
 		snd_soc_update_bits(codec, SITAR_A_BIAS_CURR_CTL_2, 0x0C, 0x08);
 		snd_soc_update_bits(codec, SITAR_A_BIAS_CENTRAL_BG_CTL, 0x2,
 			0x2);
@@ -3025,7 +2558,7 @@
 		snd_soc_write(codec, SITAR_A_BIAS_CENTRAL_BG_CTL, 0x50);
 		if (SITAR_IS_1P0(sitar_core->version))
 			snd_soc_update_bits(codec, SITAR_A_LDO_H_MODE_1,
-								0xF3, 0x61);
+								0xFF, 0x65);
 		usleep_range(1000, 1000);
 	} else {
 		pr_err("%s: Error, Invalid bandgap settings\n", __func__);
@@ -3038,23 +2571,23 @@
 {
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
 
-	pr_debug("%s: enable = %d\n", __func__, enable);
 	if (enable) {
 		snd_soc_update_bits(codec, SITAR_A_RC_OSC_FREQ, 0x10, 0);
-		/* bandgap mode to fast */
 		snd_soc_write(codec, SITAR_A_BIAS_OSC_BG_CTL, 0x17);
 		usleep_range(5, 5);
-		snd_soc_update_bits(codec, SITAR_A_RC_OSC_FREQ, 0x80, 0x80);
-		snd_soc_update_bits(codec, SITAR_A_RC_OSC_TEST, 0x80, 0x80);
+		snd_soc_update_bits(codec, SITAR_A_RC_OSC_FREQ, 0x80,
+			0x80);
+		snd_soc_update_bits(codec, SITAR_A_RC_OSC_TEST, 0x80,
+			0x80);
 		usleep_range(10, 10);
 		snd_soc_update_bits(codec, SITAR_A_RC_OSC_TEST, 0x80, 0);
-		usleep_range(10000, 10000);
+		usleep_range(20, 20);
 		snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN1, 0x08, 0x08);
 	} else {
-		snd_soc_update_bits(codec, SITAR_A_BIAS_OSC_BG_CTL, 0x1, 0);
+		snd_soc_update_bits(codec, SITAR_A_BIAS_OSC_BG_CTL, 0x1,
+			0);
 		snd_soc_update_bits(codec, SITAR_A_RC_OSC_FREQ, 0x80, 0);
-		/* clk source to ext clk and clk buff ref to VBG */
-		snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN1, 0x0C, 0x04);
+		snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN1, 0x08, 0x00);
 	}
 	sitar->config_mode_active = enable ? true : false;
 
@@ -3068,28 +2601,23 @@
 
 	pr_debug("%s\n", __func__);
 
-	/* transit to RCO requires mclk off */
-	WARN_ON(snd_soc_read(codec, SITAR_A_CLK_BUFF_EN2) & (1 << 2));
 	if (config_mode) {
-		/* enable RCO and switch to it */
 		sitar_codec_enable_config_mode(codec, 1);
 		snd_soc_write(codec, SITAR_A_CLK_BUFF_EN2, 0x00);
 		snd_soc_write(codec, SITAR_A_CLK_BUFF_EN2, 0x02);
 		snd_soc_write(codec, SITAR_A_CLK_BUFF_EN1, 0x0D);
 		usleep_range(1000, 1000);
-	} else {
-		/* switch to MCLK */
+	} else
 		snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN1, 0x08, 0x00);
 
-		if (sitar->mbhc_polling_active) {
+	if (!config_mode && sitar->mbhc_polling_active) {
 			snd_soc_write(codec, SITAR_A_CLK_BUFF_EN2, 0x02);
 			sitar_codec_enable_config_mode(codec, 0);
-		}
+
 	}
 
-	snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN1, 0x01, 0x01);
+	snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN1, 0x05, 0x05);
 	snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN2, 0x02, 0x00);
-	/* on MCLK */
 	snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN2, 0x04, 0x04);
 	usleep_range(50, 50);
 	sitar->clock_active = true;
@@ -3100,10 +2628,9 @@
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
 	pr_debug("%s\n", __func__);
 	snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN2, 0x04, 0x00);
-	usleep_range(50, 50);
+	ndelay(160);
 	snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN2, 0x02, 0x02);
 	snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN1, 0x05, 0x00);
-	usleep_range(50, 50);
 	sitar->clock_active = false;
 }
 
@@ -3119,20 +2646,6 @@
 	}
 }
 
-static s16 sitar_get_current_v_hs_max(struct sitar_priv *sitar)
-{
-	s16 v_hs_max;
-	struct sitar_mbhc_plug_type_cfg *plug_type;
-
-	plug_type = SITAR_MBHC_CAL_PLUG_TYPE_PTR(sitar->mbhc_cfg.calibration);
-	if ((sitar->mbhc_data.micb_mv != VDDIO_MICBIAS_MV) &&
-	    sitar->mbhc_micbias_switched)
-		v_hs_max = sitar->mbhc_data.adj_v_hs_max;
-	else
-		v_hs_max = plug_type->v_hs_max;
-	return v_hs_max;
-}
-
 static void sitar_codec_calibrate_hs_polling(struct snd_soc_codec *codec)
 {
 	u8 *n_ready, *n_cic;
@@ -3183,8 +2696,9 @@
 {
 	struct wcd9xxx *wcd9xxx = dev_get_drvdata(dai->codec->dev->parent);
 	if ((wcd9xxx != NULL) && (wcd9xxx->dev != NULL) &&
-			(wcd9xxx->dev->parent != NULL))
+			(wcd9xxx->dev->parent != NULL)) {
 		pm_runtime_get_sync(wcd9xxx->dev->parent);
+	}
 	pr_debug("%s(): substream = %s  stream = %d\n" , __func__,
 		substream->name, substream->stream);
 
@@ -3236,16 +2750,14 @@
 	if (mclk_enable) {
 		sitar->mclk_enabled = true;
 
-		if (sitar->mbhc_polling_active) {
+		if (sitar->mbhc_polling_active && (sitar->mclk_enabled)) {
 			sitar_codec_pause_hs_polling(codec);
-			sitar_codec_disable_clock_block(codec);
 			sitar_codec_enable_bandgap(codec,
 						   SITAR_BANDGAP_AUDIO_MODE);
 			sitar_codec_enable_clock_block(codec, 0);
 			sitar_codec_calibrate_hs_polling(codec);
 			sitar_codec_start_hs_polling(codec);
 		} else {
-			sitar_codec_disable_clock_block(codec);
 			sitar_codec_enable_bandgap(codec,
 						   SITAR_BANDGAP_AUDIO_MODE);
 			sitar_codec_enable_clock_block(codec, 0);
@@ -3261,14 +2773,15 @@
 		sitar->mclk_enabled = false;
 
 		if (sitar->mbhc_polling_active) {
+			if (!sitar->mclk_enabled) {
 			sitar_codec_pause_hs_polling(codec);
-			sitar_codec_disable_clock_block(codec);
 			sitar_codec_enable_bandgap(codec,
 						   SITAR_BANDGAP_MBHC_MODE);
 			sitar_enable_rx_bias(codec, 1);
 			sitar_codec_enable_clock_block(codec, 1);
 			sitar_codec_calibrate_hs_polling(codec);
 			sitar_codec_start_hs_polling(codec);
+			}
 			snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN1,
 					0x05, 0x01);
 		} else {
@@ -3297,7 +2810,7 @@
 	pr_debug("%s\n", __func__);
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
-		/* CPU is master */
+		
 		if (sitar->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
 			if (dai->id == AIF1_CAP)
 				snd_soc_update_bits(dai->codec,
@@ -3310,7 +2823,7 @@
 		}
 		break;
 	case SND_SOC_DAIFMT_CBM_CFM:
-	/* CPU is slave */
+	
 		if (sitar->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
 			val = SITAR_I2S_MASTER_MODE_MASK;
 			if (dai->id == AIF1_CAP)
@@ -3346,10 +2859,14 @@
 			sitar->dai[dai->id - 1].ch_tot = rx_num;
 		}
 	} else if (dai->id == AIF1_CAP) {
+#if 0
+		for (i = 0; i < tx_num; i++) {
+			sitar->dai[dai->id - 1].ch_num[i]  = tx_slot[i];
+			sitar->dai[dai->id - 1].ch_act = 0;
+			sitar->dai[dai->id - 1].ch_tot = tx_num;
+		}
+#endif
 		sitar->dai[dai->id - 1].ch_tot = tx_num;
-		/* If all channels are already active,
-		 * Do not reset ch_act flag
-		 */
 		if ((sitar->dai[dai->id - 1].ch_tot != 0)
 			&& (sitar->dai[dai->id - 1].ch_act ==
 				sitar->dai[dai->id - 1].ch_tot)) {
@@ -3383,9 +2900,6 @@
 		return -EINVAL;
 	}
 	pr_debug("%s: DAI-ID %x\n", __func__, dai->id);
-	/* for virtual port, codec driver needs to do
-	* housekeeping, for now should be ok
-	*/
 	wcd9xxx_get_channel(sitar, rx_ch, tx_ch);
 	if (dai->id == AIF1_PB) {
 		*rx_num = sitar_dai[dai->id - 1].playback.channels_max;
@@ -3395,10 +2909,18 @@
 		}
 	} else if (dai->id == AIF1_CAP) {
 		*tx_num = sitar_dai[dai->id - 1].capture.channels_max;
+#ifdef CONFIG_SND_SOC_WCD9304_SWITCH_PORT
+		tx_slot[0] = tx_ch[2 + cnt];	
+		tx_slot[1] = tx_ch[3 + cnt];	
+		tx_slot[2] = tx_ch[cnt];		
+		tx_slot[3] = tx_ch[1 + cnt];	
+#else
+		
 		tx_slot[0] = tx_ch[cnt];
 		tx_slot[1] = tx_ch[4 + cnt];
 		tx_slot[2] = tx_ch[2 + cnt];
 		tx_slot[3] = tx_ch[3 + cnt];
+#endif
 	}
 	return 0;
 }
@@ -3410,7 +2932,6 @@
 	struct snd_soc_codec *codec = dai->codec;
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(dai->codec);
 	u8 path, shift;
-	u32 compander_fs;
 	u16 tx_fs_reg, rx_fs_reg;
 	u8 tx_fs_rate, rx_fs_rate, rx_state, tx_state;
 
@@ -3420,32 +2941,18 @@
 	case 8000:
 		tx_fs_rate = 0x00;
 		rx_fs_rate = 0x00;
-		compander_fs = COMPANDER_FS_8KHZ;
 		break;
 	case 16000:
 		tx_fs_rate = 0x01;
 		rx_fs_rate = 0x20;
-		compander_fs = COMPANDER_FS_16KHZ;
 		break;
 	case 32000:
 		tx_fs_rate = 0x02;
 		rx_fs_rate = 0x40;
-		compander_fs = COMPANDER_FS_32KHZ;
 		break;
 	case 48000:
 		tx_fs_rate = 0x03;
 		rx_fs_rate = 0x60;
-		compander_fs = COMPANDER_FS_48KHZ;
-		break;
-	case 96000:
-		tx_fs_rate = 0x04;
-		rx_fs_rate = 0x80;
-		compander_fs = COMPANDER_FS_96KHZ;
-		break;
-	case 192000:
-		tx_fs_rate = 0x05;
-		rx_fs_rate = 0xa0;
-		compander_fs = COMPANDER_FS_192KHZ;
 		break;
 	default:
 		pr_err("%s: Invalid sampling rate %d\n", __func__,
@@ -3454,10 +2961,6 @@
 	}
 
 
-	/**
-	* If current dai is a tx dai, set sample rate to
-	* all the txfe paths that are currently not active
-	*/
 	if (dai->id == AIF1_CAP) {
 
 		tx_state = snd_soc_read(codec,
@@ -3496,15 +2999,7 @@
 		}
 	}
 
-	/**
-	* TODO: Need to handle case where same RX chain takes 2 or more inputs
-	* with varying sample rates
-	*/
 
-	/**
-	* If current dai is a rx dai, set sample rate to
-	* all the rx paths that are currently not active
-	*/
 	if (dai->id == AIF1_PB) {
 
 		rx_state = snd_soc_read(codec,
@@ -3518,9 +3013,6 @@
 						+ (BITS_PER_REG*(path-1));
 				snd_soc_update_bits(codec, rx_fs_reg,
 						0xE0, rx_fs_rate);
-				if (comp_rx_path[shift] < COMPANDER_MAX)
-					sitar->comp_fs[comp_rx_path[shift]]
-						= compander_fs;
 			}
 		}
 		if (sitar->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
@@ -3543,6 +3035,21 @@
 						0x03, (rx_fs_rate >> 0x05));
 		} else {
 			sitar->dai[dai->id - 1].rate   = params_rate(params);
+			sitar->dai[dai->id - 1].bit_width =
+				(params_format(params) ==
+				 SNDRV_PCM_FORMAT_S24_LE) ? 24 : 16;
+			if (sitar->dai[dai->id - 1].bit_width == 24) {
+				snd_soc_update_bits(codec, SITAR_A_CDC_CONN_RX_SB_B1_CTL,
+						0xFF, 0x00);
+				snd_soc_update_bits(codec, SITAR_A_CDC_CONN_RX_SB_B2_CTL,
+						0x03, 0x00);
+			} else {
+				snd_soc_update_bits(codec, SITAR_A_CDC_CONN_RX_SB_B1_CTL,
+						0xFF, 0xAA);
+				snd_soc_update_bits(codec, SITAR_A_CDC_CONN_RX_SB_B2_CTL,
+						0x03, 0x02);
+			}
+			sitar->dai[dai->id - 1].rate   = params_rate(params);
 		}
 	}
 
@@ -3584,38 +3091,7 @@
 			.rate_max = 48000,
 			.rate_min = 8000,
 			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &sitar_dai_ops,
-	},
-};
-
-static struct snd_soc_dai_driver sitar_i2s_dai[] = {
-	{
-		.name = "sitar_i2s_rx1",
-		.id = AIF1_PB,
-		.playback = {
-			.stream_name = "AIF1 Playback",
-			.rates = WCD9304_RATES,
-			.formats = SITAR_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &sitar_dai_ops,
-	},
-	{
-		.name = "sitar_i2s_tx1",
-		.id = AIF1_CAP,
-		.capture = {
-			.stream_name = "AIF1 Capture",
-			.rates = WCD9304_RATES,
-			.formats = SITAR_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
+			.channels_max = 2,
 		},
 		.ops = &sitar_dai_ops,
 	},
@@ -3657,6 +3133,37 @@
 	return ret;
 }
 
+static struct snd_soc_dai_driver sitar_i2s_dai[] = {
+	{
+		.name = "sitar_i2s_rx1",
+		.id = AIF1_PB,
+		.playback = {
+			.stream_name = "AIF1 Playback",
+			.rates = WCD9304_RATES,
+			.formats = SITAR_FORMATS,
+			.rate_max = 192000,
+			.rate_min = 8000,
+			.channels_min = 1,
+			.channels_max = 4,
+		},
+		.ops = &sitar_dai_ops,
+	},
+	{
+		.name = "sitar_i2s_tx1",
+		.id = AIF1_CAP,
+		.capture = {
+			.stream_name = "AIF1 Capture",
+			.rates = WCD9304_RATES,
+			.formats = SITAR_FORMATS,
+			.rate_max = 192000,
+			.rate_min = 8000,
+			.channels_min = 1,
+			.channels_max = 4,
+		},
+		.ops = &sitar_dai_ops,
+	},
+};
+
 static int sitar_codec_enable_slimrx(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
@@ -3668,7 +3175,6 @@
 	codec->control_data = dev_get_drvdata(codec->dev->parent);
 	sitar = codec->control_data;
 
-	/* Execute the callback only if interface type is slimbus */
 	if (sitar_p->intf_type != WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
 		if (event == SND_SOC_DAPM_POST_PMD && (sitar != NULL))
 			sitar_codec_pm_runtime_put(sitar);
@@ -3688,12 +3194,17 @@
 				break;
 			}
 		}
-		if (sitar_p->dai[j].ch_act == sitar_p->dai[j].ch_tot) {
+		if (( j < ARRAY_SIZE(sitar_dai)) && (sitar_p->dai[j].ch_act == sitar_p->dai[j].ch_tot)) {
 			ret = sitar_codec_enable_chmask(sitar_p, event, j);
+
+			if (sitar_p->dai[j].bit_width == 0)
+				sitar_p->dai[j].bit_width = 16;
+
 			ret = wcd9xxx_cfg_slim_sch_rx(sitar,
 					sitar_p->dai[j].ch_num,
 					sitar_p->dai[j].ch_tot,
-					sitar_p->dai[j].rate);
+					sitar_p->dai[j].rate,
+					sitar_p->dai[j].bit_width);
 		}
 		break;
 	case SND_SOC_DAPM_POST_PMD:
@@ -3707,10 +3218,12 @@
 				break;
 			}
 		}
-		if (!sitar_p->dai[j].ch_act) {
+		if ((j < ARRAY_SIZE(sitar_dai)) && (!sitar_p->dai[j].ch_act)) {
 			wcd9xxx_close_slim_sch_rx(sitar,
 					sitar_p->dai[j].ch_num,
 					sitar_p->dai[j].ch_tot);
+			usleep_range(15000, 15000);
+
 			ret = sitar_codec_enable_chmask(sitar_p, event, j);
 			if (ret < 0) {
 				ret = wcd9xxx_disconnect_port(sitar,
@@ -3737,20 +3250,19 @@
 	struct wcd9xxx *sitar;
 	struct snd_soc_codec *codec = w->codec;
 	struct sitar_priv *sitar_p = snd_soc_codec_get_drvdata(codec);
-	/* index to the DAI ID, for now hardcoding */
+	
 	u32  j = 0;
 	int ret = 0;
 
 	codec->control_data = dev_get_drvdata(codec->dev->parent);
 	sitar = codec->control_data;
 
-	/* Execute the callback only if interface type is slimbus */
+	
 	if (sitar_p->intf_type != WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
 		if (event == SND_SOC_DAPM_POST_PMD && (sitar != NULL))
 			sitar_codec_pm_runtime_put(sitar);
 		return 0;
 	}
-
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
 		for (j = 0; j < ARRAY_SIZE(sitar_dai); j++) {
@@ -3762,13 +3274,14 @@
 				break;
 			}
 		}
-		if (sitar_p->dai[j].ch_act == sitar_p->dai[j].ch_tot) {
+		if (( j < ARRAY_SIZE(sitar_dai)) && (sitar_p->dai[j].ch_act == sitar_p->dai[j].ch_tot)) {
 			ret = sitar_codec_enable_chmask(sitar_p, event, j);
 			ret = wcd9xxx_cfg_slim_sch_tx(sitar,
 					sitar_p->dai[j].ch_num,
 					sitar_p->dai[j].ch_tot,
 					sitar_p->dai[j].rate);
 		}
+		usleep_range(50000, 50000);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
 		for (j = 0; j < ARRAY_SIZE(sitar_dai); j++) {
@@ -3780,7 +3293,7 @@
 				break;
 			}
 		}
-		if (!sitar_p->dai[j].ch_act) {
+		if ((j < ARRAY_SIZE(sitar_dai)) && (!sitar_p->dai[j].ch_act)) {
 			wcd9xxx_close_slim_sch_tx(sitar,
 					sitar_p->dai[j].ch_num,
 					sitar_p->dai[j].ch_tot);
@@ -3793,6 +3306,7 @@
 				pr_info("%s: Disconnect TX port, ret = %d\n",
 						__func__, ret);
 			}
+
 			sitar_p->dai[j].rate = 0;
 			memset(sitar_p->dai[j].ch_num, 0, (sizeof(u32)*
 					sitar_p->dai[j].ch_tot));
@@ -3804,7 +3318,6 @@
 	return ret;
 }
 
-
 static short sitar_codec_read_sta_result(struct snd_soc_codec *codec)
 {
 	u8 bias_msb, bias_lsb;
@@ -3843,7 +3356,7 @@
 	if (noreldetection)
 		sitar_turn_onoff_rel_detection(codec, false);
 
-	/* Turn on the override */
+	
 	if (!override_bypass)
 		snd_soc_update_bits(codec, SITAR_A_CDC_MBHC_B1_CTL, 0x4, 0x4);
 	if (dce) {
@@ -3869,7 +3382,7 @@
 		snd_soc_update_bits(codec, SITAR_A_CDC_MBHC_CLK_CTL, 0x8, 0x8);
 		snd_soc_write(codec, SITAR_A_CDC_MBHC_EN_CTL, 0x0);
 	}
-	/* Turn off the override after measuring mic voltage */
+	
 	if (!override_bypass)
 		snd_soc_update_bits(codec, SITAR_A_CDC_MBHC_B1_CTL, 0x04, 0x00);
 
@@ -3925,7 +3438,6 @@
 	sitar->mbhc_state = MBHC_STATE_NONE;
 }
 
-/* called only from interrupt which is under codec_resource_lock acquisition */
 static short sitar_codec_setup_hs_polling(struct snd_soc_codec *codec)
 {
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
@@ -3938,7 +3450,6 @@
 	}
 
 	if (!sitar->mclk_enabled) {
-		sitar_codec_disable_clock_block(codec);
 		sitar_codec_enable_bandgap(codec, SITAR_BANDGAP_MBHC_MODE);
 		sitar_enable_rx_bias(codec, 1);
 		sitar_codec_enable_clock_block(codec, 1);
@@ -3946,7 +3457,7 @@
 
 	snd_soc_update_bits(codec, SITAR_A_CLK_BUFF_EN1, 0x05, 0x01);
 
-	/* Make sure CFILT is in fast mode, save current mode */
+	
 	cfilt_mode = snd_soc_read(codec, sitar->mbhc_bias_regs.cfilt_ctl);
 	snd_soc_update_bits(codec, sitar->mbhc_bias_regs.cfilt_ctl, 0x70, 0x00);
 
@@ -3968,7 +3479,7 @@
 
 	sitar_codec_calibrate_hs_polling(codec);
 
-	/* don't flip override */
+	
 	bias_value = __sitar_codec_sta_dce(codec, 1, true, true);
 	snd_soc_update_bits(codec, sitar->mbhc_bias_regs.cfilt_ctl, 0x40,
 			    cfilt_mode);
@@ -3983,8 +3494,6 @@
 	struct wcd9xxx *core = dev_get_drvdata(sitar->codec->dev->parent);
 
 	if (cancel_delayed_work_sync(&sitar->mbhc_btn_dwork)) {
-		/* if scheduled mbhc_btn_dwork is canceled from here,
-		 * we have to unlock from here instead btn_work */
 		wcd9xxx_unlock_sleep(core);
 		r = 1;
 	}
@@ -4019,11 +3528,11 @@
 	return (u16) (in / mb_mv) + zero;
 }
 
-static s32 __sitar_codec_sta_dce_v(struct snd_soc_codec *codec, s8 dce,
-				 u16 bias_value, s16 z)
+static s32 sitar_codec_sta_dce_v(struct snd_soc_codec *codec, s8 dce,
+				 u16 bias_value)
 {
 	struct sitar_priv *sitar;
-	s16 value, mb;
+	s16 value, z, mb;
 	s32 mv;
 
 	sitar = snd_soc_codec_get_drvdata(codec);
@@ -4042,23 +3551,13 @@
 	return mv;
 }
 
-static s32 sitar_codec_sta_dce_v(struct snd_soc_codec *codec, s8 dce,
-				 u16 bias_value)
-{
-	s16 z;
-	struct sitar_priv *sitar;
-	sitar = snd_soc_codec_get_drvdata(codec);
-	z = dce ? (s16)sitar->mbhc_data.dce_z : (s16)sitar->mbhc_data.sta_z;
-	return __sitar_codec_sta_dce_v(sitar->codec, dce, bias_value, z);
-}
-
 static void btn_lpress_fn(struct work_struct *work)
 {
 	struct delayed_work *delayed_work;
 	struct sitar_priv *sitar;
 	short bias_value;
 	int dce_mv, sta_mv;
-	struct wcd9xxx *core;
+	struct wcd9xxx *core = NULL;
 
 	pr_debug("%s:\n", __func__);
 
@@ -4107,10 +3606,6 @@
 	wcd9xxx_disable_irq(codec->control_data, SITAR_IRQ_MBHC_POTENTIAL);
 	sitar_turn_onoff_rel_detection(codec, false);
 
-	/* First compute the DCE / STA wait times
-	 * depending on tunable parameters.
-	 * The value is computed in microseconds
-	 */
 	btn_det = SITAR_MBHC_CAL_BTN_DET_PTR(calibration);
 	n_cic = sitar_mbhc_cal_btn_det_mp(btn_det, SITAR_BTN_DET_N_CIC);
 	ncic = n_cic[sitar_codec_mclk_index(sitar)];
@@ -4120,21 +3615,14 @@
 	dce_wait = (1000 * 512 * 60 * (nmeas + 1)) / (mclk_rate / 1000);
 	sta_wait = (1000 * 128 * (navg + 1)) / (mclk_rate / 1000);
 
-	sitar->mbhc_data.t_dce = dce_wait;
-	sitar->mbhc_data.t_sta = sta_wait;
+	sitar->mbhc_data.t_dce = DEFAULT_DCE_WAIT;
+	sitar->mbhc_data.t_sta = DEFAULT_STA_WAIT;
 
-	/* LDOH and CFILT are already configured during pdata handling.
-	 * Only need to make sure CFILT and bandgap are in Fast mode.
-	 * Need to restore defaults once calculation is done.
-	 */
 	cfilt_mode = snd_soc_read(codec, sitar->mbhc_bias_regs.cfilt_ctl);
 	snd_soc_update_bits(codec, sitar->mbhc_bias_regs.cfilt_ctl, 0x40, 0x00);
 	bg_mode = snd_soc_update_bits(codec, SITAR_A_BIAS_CENTRAL_BG_CTL, 0x02,
 				      0x02);
 
-	/* Micbias, CFILT, LDOH, MBHC MUX mode settings
-	 * to perform ADC calibration
-	 */
 	snd_soc_update_bits(codec, sitar->mbhc_bias_regs.ctl_reg, 0x60,
 			    sitar->mbhc_cfg.micbias << 5);
 	snd_soc_update_bits(codec, sitar->mbhc_bias_regs.ctl_reg, 0x01, 0x00);
@@ -4142,59 +3630,43 @@
 	snd_soc_write(codec, SITAR_A_TX_4_MBHC_TEST_CTL, 0x78);
 	snd_soc_update_bits(codec, SITAR_A_CDC_MBHC_B1_CTL, 0x04, 0x04);
 
-	/* DCE measurement for 0 volts */
+	
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_CLK_CTL, 0x0A);
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_EN_CTL, 0x04);
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_CLK_CTL, 0x02);
 	snd_soc_write(codec, SITAR_A_MBHC_SCALING_MUX_1, 0x81);
-	/*
-	* Hardware that has external cap can delay mic bias ramping down up
-	* to 50ms.
-	*/
-	msleep(SITAR_MUX_SWITCH_READY_WAIT_MS);
+	usleep_range(100, 100);
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_EN_CTL, 0x04);
 	usleep_range(sitar->mbhc_data.t_dce, sitar->mbhc_data.t_dce);
 	sitar->mbhc_data.dce_z = sitar_codec_read_dce_result(codec);
 
-	/* DCE measurment for MB voltage */
+	
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_CLK_CTL, 0x0A);
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_CLK_CTL, 0x02);
 	snd_soc_write(codec, SITAR_A_MBHC_SCALING_MUX_1, 0x82);
-	/*
-	* Hardware that has external cap can delay mic bias ramping down up
-	* to 50ms.
-	*/
-	msleep(SITAR_MUX_SWITCH_READY_WAIT_MS);
+	usleep_range(100, 100);
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_EN_CTL, 0x04);
 	usleep_range(sitar->mbhc_data.t_dce, sitar->mbhc_data.t_dce);
 	sitar->mbhc_data.dce_mb = sitar_codec_read_dce_result(codec);
 
-	/* Sta measuremnt for 0 volts */
+	
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_CLK_CTL, 0x0A);
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_EN_CTL, 0x02);
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_CLK_CTL, 0x02);
 	snd_soc_write(codec, SITAR_A_MBHC_SCALING_MUX_1, 0x81);
-	/*
-	* Hardware that has external cap can delay mic bias ramping down up
-	* to 50ms.
-	*/
-	msleep(SITAR_MUX_SWITCH_READY_WAIT_MS);
+	usleep_range(100, 100);
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_EN_CTL, 0x02);
 	usleep_range(sitar->mbhc_data.t_sta, sitar->mbhc_data.t_sta);
 	sitar->mbhc_data.sta_z = sitar_codec_read_sta_result(codec);
 
-	/* STA Measurement for MB Voltage */
+	
 	snd_soc_write(codec, SITAR_A_MBHC_SCALING_MUX_1, 0x82);
-	/*
-	* Hardware that has external cap can delay mic bias ramping down up
-	* to 50ms.
-	*/
-	msleep(SITAR_MUX_SWITCH_READY_WAIT_MS);
+	usleep_range(100, 100);
 	snd_soc_write(codec, SITAR_A_CDC_MBHC_EN_CTL, 0x02);
 	usleep_range(sitar->mbhc_data.t_sta, sitar->mbhc_data.t_sta);
 	sitar->mbhc_data.sta_mb = sitar_codec_read_sta_result(codec);
 
-	/* Restore default settings. */
+	
 	snd_soc_update_bits(codec, SITAR_A_CDC_MBHC_B1_CTL, 0x04, 0x00);
 	snd_soc_update_bits(codec, sitar->mbhc_bias_regs.cfilt_ctl, 0x40,
 			    cfilt_mode);
@@ -4202,6 +3674,7 @@
 
 	snd_soc_write(codec, SITAR_A_MBHC_SCALING_MUX_1, 0x84);
 	usleep_range(100, 100);
+
 	wcd9xxx_enable_irq(codec->control_data, SITAR_IRQ_MBHC_POTENTIAL);
 	sitar_turn_onoff_rel_detection(codec, true);
 }
@@ -4221,7 +3694,7 @@
 	case SITAR_BTN_DET_V_BTN_HIGH:
 		ret += sizeof(btn_det->_v_btn_low[0]) * btn_det->num_btn;
 	case SITAR_BTN_DET_V_BTN_LOW:
-		/* do nothing */
+		
 		break;
 	default:
 		ret = NULL;
@@ -4230,22 +3703,6 @@
 	return ret;
 }
 
-static s16 sitar_scale_v_micb_vddio(struct sitar_priv *sitar, int volt_val,
-				    bool tovddio)
-{
-	int k_val_ratio;
-	int vddio_k, mb_k;
-	vddio_k = sitar_find_k_value(sitar->pdata->micbias.ldoh_v,
-				     VDDIO_MICBIAS_MV);
-	mb_k = sitar_find_k_value(sitar->pdata->micbias.ldoh_v,
-				  sitar->mbhc_data.micb_mv);
-	if (tovddio)
-		k_val_ratio = volt_val * (vddio_k + 4) / (mb_k + 4);
-	else
-		k_val_ratio = volt_val * (mb_k + 4) / (vddio_k + 4);
-	return k_val_ratio;
-}
-
 static void sitar_mbhc_calc_thres(struct snd_soc_codec *codec)
 {
 	struct sitar_priv *sitar;
@@ -4282,10 +3739,6 @@
 	for (i = 0; i < btn_det->num_btn; i++)
 		btn_mv = btn_high[i] > btn_mv ? btn_high[i] : btn_mv;
 
-	if (sitar->mbhc_data.micb_mv != VDDIO_MICBIAS_MV)
-		sitar->mbhc_data.adj_v_hs_max =
-		    sitar_scale_v_micb_vddio(sitar, plug_type->v_hs_max, true);
-
 	sitar->mbhc_data.v_b1_h = sitar_codec_v_sta_dce(codec, DCE, btn_mv);
 	btn_delta_mv = btn_mv + btn_det->v_btn_press_delta_sta;
 
@@ -4312,7 +3765,7 @@
 	int n;
 	u8 *n_cic, *gain;
 
-	pr_err("%s(): ENTER\n", __func__);
+	pr_info("%s(): ENTER\n", __func__);
 	sitar = snd_soc_codec_get_drvdata(codec);
 	generic = SITAR_MBHC_CAL_GENERAL_PTR(sitar->mbhc_cfg.calibration);
 	btn_det = SITAR_MBHC_CAL_BTN_DET_PTR(sitar->mbhc_cfg.calibration);
@@ -4365,20 +3818,17 @@
 	struct sitar_mbhc_imped_detect_cfg *imped_cfg;
 	struct sitar_mbhc_btn_detect_cfg *btn_cfg;
 
+        if (!fw)
+		return false;
+
 	if (fw->size < SITAR_MBHC_CAL_MIN_SIZE)
 		return false;
 
-	/* previous check guarantees that there is enough fw data up
-	 * to num_btn
-	 */
 	btn_cfg = SITAR_MBHC_CAL_BTN_DET_PTR(fw->data);
 	cfg_offset = (u32) ((void *) btn_cfg - (void *) fw->data);
 	if (fw->size < (cfg_offset + SITAR_MBHC_CAL_BTN_SZ(btn_cfg)))
 		return false;
 
-	/* previous check guarantees that there is enough fw data up
-	 * to start of impedance detection configuration
-	 */
 	imped_cfg = SITAR_MBHC_CAL_IMPED_DET_PTR(fw->data);
 	cfg_offset = (u32) ((void *) imped_cfg - (void *) fw->data);
 
@@ -4397,7 +3847,6 @@
 	snd_soc_update_bits(codec, SITAR_A_CDC_MBHC_B1_CTL, 0x04, on << 2);
 }
 
-/* called under codec_resource_lock acquisition */
 void sitar_set_and_turnoff_hph_padac(struct snd_soc_codec *codec)
 {
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
@@ -4406,8 +3855,6 @@
 	wg_time = snd_soc_read(codec, SITAR_A_RX_HPH_CNP_WG_TIME) ;
 	wg_time += 1;
 
-	/* If headphone PA is on, check if userspace receives
-	 * removal event to sync-up PA's state */
 	if (sitar_is_hph_pa_on(codec)) {
 		pr_debug("%s PA is on, setting PA_OFF_ACK\n", __func__);
 		set_bit(SITAR_HPHL_PA_OFF_ACK, &sitar->hph_pa_dac_state);
@@ -4479,11 +3926,9 @@
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
 
 	if (!insertion) {
-		/* Report removal */
+		
 		sitar->hph_status &= ~jack_type;
 		if (sitar->mbhc_cfg.headset_jack) {
-			/* cancel possibly scheduled btn work and
-			* report release if we reported button press */
 			if (sitar_cancel_btn_work(sitar)) {
 				pr_debug("%s: button press is canceled\n",
 					__func__);
@@ -4497,8 +3942,8 @@
 				sitar->buttons_pressed &=
 							~SITAR_JACK_BUTTON_MASK;
 			}
-			pr_debug("%s: Reporting removal %d(%x)\n", __func__,
-				 jack_type, sitar->hph_status);
+			pr_debug("%s: Reporting removal %d\n", __func__,
+				 jack_type);
 			sitar_snd_soc_jack_report(sitar,
 						  sitar->mbhc_cfg.headset_jack,
 						  sitar->hph_status,
@@ -4512,20 +3957,18 @@
 		sitar->current_plug = PLUG_TYPE_NONE;
 		sitar->mbhc_polling_active = false;
 	} else {
-		/* Report insertion */
+		
 		sitar->hph_status |= jack_type;
 
 		if (jack_type == SND_JACK_HEADPHONE)
 			sitar->current_plug = PLUG_TYPE_HEADPHONE;
-		else if (jack_type == SND_JACK_UNSUPPORTED)
-			sitar->current_plug = PLUG_TYPE_GND_MIC_SWAP;
 		else if (jack_type == SND_JACK_HEADSET) {
 			sitar->mbhc_polling_active = true;
 			sitar->current_plug = PLUG_TYPE_HEADSET;
 		}
 		if (sitar->mbhc_cfg.headset_jack) {
-			pr_debug("%s: Reporting insertion %d(%x)\n", __func__,
-				 jack_type, sitar->hph_status);
+			pr_debug("%s: Reporting insertion %d\n", __func__,
+				 jack_type);
 			sitar_snd_soc_jack_report(sitar,
 						  sitar->mbhc_cfg.headset_jack,
 						  sitar->hph_status,
@@ -4542,26 +3985,23 @@
 		sitar->mbhc_cfg.gpio_level_insert);
 }
 
-static bool sitar_is_inval_ins_delta(struct snd_soc_codec *codec,
+static bool sitar_is_invalid_insert_delta(struct snd_soc_codec *codec,
 					int mic_volt, int mic_volt_prev)
 {
-	return abs(mic_volt - mic_volt_prev) >
-				SITAR_MBHC_FAKE_INSERT_VOLT_DELTA_MV;
+	int delta = abs(mic_volt - mic_volt_prev);
+	if (delta > SITAR_MBHC_FAKE_INSERT_VOLT_DELTA_MV) {
+		pr_debug("%s: volt delta %dmv\n", __func__, delta);
+		return true;
+	}
+	return false;
 }
 
-static bool sitar_is_inval_ins_range(struct snd_soc_codec *codec,
-				       s32 mic_volt,  bool *highv)
+static bool sitar_is_invalid_insertion_range(struct snd_soc_codec *codec,
+				       s32 mic_volt)
 {
 	bool invalid = false;
-	s16 v_hs_max;
-	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
 
-	v_hs_max = sitar_get_current_v_hs_max(sitar);
-	*highv = mic_volt > v_hs_max;
-
-	if (*highv)
-		invalid = true;
-	else if (mic_volt < SITAR_MBHC_FAKE_INSERT_HIGH
+	if (mic_volt < SITAR_MBHC_FAKE_INSERT_HIGH
 			&& (mic_volt > SITAR_MBHC_FAKE_INSERT_LOW)) {
 		invalid = true;
 	}
@@ -4569,7 +4009,38 @@
 	return invalid;
 }
 
-/* called under codec_resource_lock acquisition */
+static bool sitar_codec_is_invalid_plug(struct snd_soc_codec *codec,
+	s32 mic_mv[MBHC_NUM_DCE_PLUG_DETECT],
+	enum sitar_mbhc_plug_type plug_type[MBHC_NUM_DCE_PLUG_DETECT])
+{
+	int i;
+	bool r = false;
+	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
+	struct sitar_mbhc_plug_type_cfg *plug_type_ptr =
+		SITAR_MBHC_CAL_PLUG_TYPE_PTR(sitar->mbhc_cfg.calibration);
+
+	for (i = 0 ; i < MBHC_NUM_DCE_PLUG_DETECT && !r; i++) {
+		if (mic_mv[i] < plug_type_ptr->v_no_mic)
+			plug_type[i] = PLUG_TYPE_HEADPHONE;
+		else if (mic_mv[i] < plug_type_ptr->v_hs_max)
+			plug_type[i] = PLUG_TYPE_HEADSET;
+		else if (mic_mv[i] > plug_type_ptr->v_hs_max)
+			plug_type[i] = PLUG_TYPE_HIGH_HPH;
+
+		r = sitar_is_invalid_insertion_range(codec, mic_mv[i]);
+		if (!r && i > 0) {
+			if (plug_type[i-1] != plug_type[i])
+				r = true;
+			else
+				r = sitar_is_invalid_insert_delta(codec,
+							mic_mv[i],
+							mic_mv[i - 1]);
+		}
+	}
+
+	return r;
+}
+
 void sitar_find_plug_and_report(struct snd_soc_codec *codec,
 				enum sitar_mbhc_plug_type plug_type)
 {
@@ -4577,25 +4048,9 @@
 
 	if (plug_type == PLUG_TYPE_HEADPHONE
 		&& sitar->current_plug == PLUG_TYPE_NONE) {
-		/*
-		 * Nothing was reported previously
-		 * report a headphone or unsupported
-		 */
 		sitar_codec_report_plug(codec, 1, SND_JACK_HEADPHONE);
 		sitar_codec_cleanup_hs_polling(codec);
-	} else if (plug_type == PLUG_TYPE_GND_MIC_SWAP) {
-		if (sitar->current_plug == PLUG_TYPE_HEADSET)
-			sitar_codec_report_plug(codec, 0, SND_JACK_HEADSET);
-		else if (sitar->current_plug == PLUG_TYPE_HEADPHONE)
-			sitar_codec_report_plug(codec, 0, SND_JACK_HEADPHONE);
-
-		sitar_codec_report_plug(codec, 1, SND_JACK_UNSUPPORTED);
-		msleep(100);
-		sitar_codec_cleanup_hs_polling(codec);
 	} else if (plug_type == PLUG_TYPE_HEADSET) {
-		/* If Headphone was reported previously, this will
-		 * only report the mic line
-		 */
 		sitar_codec_report_plug(codec, 1, SND_JACK_HEADSET);
 		msleep(100);
 		sitar_codec_start_hs_polling(codec);
@@ -4605,15 +4060,11 @@
 		sitar_codec_cleanup_hs_polling(codec);
 		pr_debug("setup mic trigger for further detection\n");
 		sitar->lpi_enabled = true;
-		/* TODO ::: sitar_codec_enable_hs_detect */
+		
 		pr_err("%s(): High impedence hph not supported\n", __func__);
-	} else {
-		WARN(1, "Unexpected current plug_type %d, plug_type %d\n",
-			sitar->current_plug, plug_type);
 	}
 }
 
-/* should be called under interrupt context that hold suspend */
 static void sitar_schedule_hs_detect_plug(struct sitar_priv *sitar)
 {
 	pr_debug("%s: scheduling sitar_hs_correct_gpio_plug\n", __func__);
@@ -4622,7 +4073,6 @@
 	schedule_work(&sitar->hs_correct_plug_work);
 }
 
-/* called under codec_resource_lock acquisition */
 static void sitar_cancel_hs_detect_plug(struct sitar_priv *sitar)
 {
 	pr_debug("%s: canceling hs_correct_plug_work\n", __func__);
@@ -4640,9 +4090,11 @@
 {
 	struct sitar_priv *sitar;
 	struct snd_soc_codec *codec;
-	int retry = 0, pt_gnd_mic_swap_cnt = 0;
+	int retry = 0, i;
 	bool correction = false;
-	enum sitar_mbhc_plug_type plug_type;
+	s32 mic_mv[MBHC_NUM_DCE_PLUG_DETECT];
+	short mb_v[MBHC_NUM_DCE_PLUG_DETECT];
+	enum sitar_mbhc_plug_type plug_type[MBHC_NUM_DCE_PLUG_DETECT];
 	unsigned long timeout;
 
 	sitar = container_of(work, struct sitar_priv, hs_correct_plug_work);
@@ -4651,15 +4103,6 @@
 	pr_debug("%s: enter\n", __func__);
 	sitar->mbhc_cfg.mclk_cb_fn(codec, 1, false);
 
-	/* Keep override on during entire plug type correction work.
-	 *
-	 * This is okay under the assumption that any GPIO irqs which use
-	 * MBHC block cancel and sync this work so override is off again
-	 * prior to GPIO interrupt handler's MBHC block usage.
-	 * Also while this correction work is running, we can guarantee
-	 * DAPM doesn't use any MBHC block as this work only runs with
-	 * headphone detection.
-	 */
 	sitar_turn_onoff_override(codec, true);
 
 	timeout = jiffies + msecs_to_jiffies(SITAR_HS_DETECT_PLUG_TIME_MS);
@@ -4677,204 +4120,96 @@
 			break;
 		}
 
-		/* can race with removal interrupt */
+		
 		SITAR_ACQUIRE_LOCK(sitar->codec_resource_lock);
-		plug_type = sitar_codec_decide_gpio_plug(codec);
+		for (i = 0; i < MBHC_NUM_DCE_PLUG_DETECT; i++) {
+			mb_v[i] = __sitar_codec_sta_dce(codec, 1, true, true);
+			mic_mv[i] = sitar_codec_sta_dce_v(codec, 1 , mb_v[i]);
+			pr_debug("%s : DCE run %d, mic_mv = %d(%x)\n",
+				 __func__, retry, mic_mv[i], mb_v[i]);
+		}
 		SITAR_RELEASE_LOCK(sitar->codec_resource_lock);
 
-		if (plug_type == PLUG_TYPE_INVALID) {
+		if (sitar_codec_is_invalid_plug(codec, mic_mv, plug_type)) {
 			pr_debug("Invalid plug in attempt # %d\n", retry);
 			if (retry == NUM_ATTEMPTS_TO_REPORT &&
 			    sitar->current_plug == PLUG_TYPE_NONE) {
 				sitar_codec_report_plug(codec, 1,
 							SND_JACK_HEADPHONE);
 			}
-		} else if (plug_type == PLUG_TYPE_HEADPHONE) {
+		} else if (!sitar_codec_is_invalid_plug(codec, mic_mv,
+							plug_type) &&
+			   plug_type[0] == PLUG_TYPE_HEADPHONE) {
 			pr_debug("Good headphone detected, continue polling mic\n");
-			if (sitar->current_plug == PLUG_TYPE_NONE)
+			if (sitar->current_plug == PLUG_TYPE_NONE) {
 				sitar_codec_report_plug(codec, 1,
 							SND_JACK_HEADPHONE);
-		} else {
-			if (plug_type == PLUG_TYPE_GND_MIC_SWAP) {
-				pt_gnd_mic_swap_cnt++;
-				if (pt_gnd_mic_swap_cnt <
-					SITAR_MBHC_GND_MIC_SWAP_THRESHOLD)
-					continue;
-				else if (pt_gnd_mic_swap_cnt >
-					SITAR_MBHC_GND_MIC_SWAP_THRESHOLD) {
-					/*
-					 * This is due to GND/MIC switch didn't
-					 * work,  Report unsupported plug
-					 */
-				} else if (sitar->mbhc_cfg.swap_gnd_mic) {
-					/*
-					 * if switch is toggled, check again,
-					 * otherwise report unsupported plug
-					 */
-					if (sitar->mbhc_cfg.swap_gnd_mic(codec))
-						continue;
 				}
-			} else
-				pt_gnd_mic_swap_cnt = 0;
-
+		} else {
 			SITAR_ACQUIRE_LOCK(sitar->codec_resource_lock);
-			/* Turn off override */
+			
 			sitar_turn_onoff_override(codec, false);
-			/*
-			 * The valid plug also includes PLUG_TYPE_GND_MIC_SWAP
-			 */
-			sitar_find_plug_and_report(codec, plug_type);
+			sitar_find_plug_and_report(codec, plug_type[0]);
 			SITAR_RELEASE_LOCK(sitar->codec_resource_lock);
 			pr_debug("Attempt %d found correct plug %d\n", retry,
-				 plug_type);
+				 plug_type[0]);
 			correction = true;
 			break;
 		}
 	}
 
-	/* Turn off override */
+	
 	if (!correction)
 		sitar_turn_onoff_override(codec, false);
 
 	sitar->mbhc_cfg.mclk_cb_fn(codec, 0, false);
 	pr_debug("%s: leave\n", __func__);
-	/* unlock sleep */
+	
 	wcd9xxx_unlock_sleep(sitar->codec->control_data);
 }
 
-/* called under codec_resource_lock acquisition */
-static void sitar_codec_hphr_gnd_switch(struct snd_soc_codec *codec, bool on)
-{
-	snd_soc_update_bits(codec, SITAR_A_MBHC_HPH, 0x01, on);
-	if (on)
-		usleep_range(SITAR_MIC_GND_SWAP_DELAY_US,
-			SITAR_MIC_GND_SWAP_DELAY_US +
-			SITAR_USLEEP_RANGE_TOLERANCE);
-}
-
-/* called under codec_resource_lock acquisition */
-static enum sitar_mbhc_plug_type
-sitar_codec_decide_gpio_plug(struct snd_soc_codec *codec)
+static void sitar_codec_decide_gpio_plug(struct snd_soc_codec *codec)
 {
-	bool gndswitch;
-	int scaled;
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
-	int num_det = MBHC_NUM_DCE_PLUG_DETECT + 1;
-	short mb_v[num_det];
-	s32 mic_mv[num_det];
-	enum sitar_mbhc_plug_type plug_type[num_det];
+	short mb_v[MBHC_NUM_DCE_PLUG_DETECT];
+	s32 mic_mv[MBHC_NUM_DCE_PLUG_DETECT];
+	enum sitar_mbhc_plug_type plug_type[MBHC_NUM_DCE_PLUG_DETECT];
 	int i;
-	bool inval;
-	bool highdelta;
-	bool ahighv = false, highv, r = false;
-	bool gndmicswapped = false;
 
-	struct sitar_mbhc_plug_type_cfg *plug_type_ptr =
-		SITAR_MBHC_CAL_PLUG_TYPE_PTR(sitar->mbhc_cfg.calibration);
 	pr_debug("%s: enter\n", __func__);
 
 	sitar_turn_onoff_override(codec, true);
-
-	/* GND and MIC swap detection requires at least 2 rounds of DCE */
-	BUG_ON(num_det < 2);
-
-	plug_type[0] = PLUG_TYPE_INVALID;
-
-
-	for (i = 0; i < num_det; i++) {
-		gndswitch = (i == (num_det - 2));
-		if (i == 0) {
 			mb_v[0] = sitar_codec_setup_hs_polling(codec);
 			mic_mv[0] = sitar_codec_sta_dce_v(codec, 1, mb_v[0]);
-			pr_debug("%s: DCE run 1, mic_mv = %d\n",
-				__func__, mic_mv[0]);
-			inval = sitar_is_inval_ins_range(codec, mic_mv[0],
-							&highv);
-			ahighv |= highv;
-			scaled = mic_mv[i];
-		} else {
-			if (gndswitch)
-				sitar_codec_hphr_gnd_switch(codec, true);
+	pr_debug("%s: DCE run 1, mic_mv = %d\n", __func__, mic_mv[0]);
+
+	for (i = 1; i < MBHC_NUM_DCE_PLUG_DETECT; i++) {
 			mb_v[i] = __sitar_codec_sta_dce(codec, 1, true, true);
 			mic_mv[i] = sitar_codec_sta_dce_v(codec, 1 , mb_v[i]);
-			pr_debug("%s: DCE run %d, mic_mv = %d\n",
-					__func__, i + 1, mic_mv[i]);
-			scaled = mic_mv[i];
-
-			/* !gndswitch & vddioswitch means the previous DCE
-			 * was done with gndswitch, don't compare with DCE
-			 * with gndswitch */
-			highdelta = sitar_is_inval_ins_delta(codec, scaled,
-							mic_mv[i - 1]);
-			inval = (sitar_is_inval_ins_range(codec, mic_mv[i],
-							&highv) ||
-							highdelta);
-			ahighv |= highv;
-			if (gndswitch)
-				sitar_codec_hphr_gnd_switch(codec, false);
-
-			/* claim UNSUPPORTED plug insertion when
-			 * good headset is detected but HPHR GND switch makes
-			 * delta difference */
-			if (i == (num_det - 2) && highdelta && !ahighv)
-				gndmicswapped = true;
-			else if (i == (num_det - 1) && inval) {
-				if (gndmicswapped)
-					plug_type[0] = PLUG_TYPE_GND_MIC_SWAP;
-				else
-					plug_type[0] = PLUG_TYPE_INVALID;
-			}
-		}
-		pr_debug("%s: DCE #%d, %04x, V %d, scaled V %d, GND %d, " \
-			"inval %d\n", __func__,
-			i + 1, mb_v[i] & 0xffff, mic_mv[i], scaled, gndswitch,
-			inval);
-		/* don't need to run further DCEs */
-		if (ahighv && inval)
-			break;
-		mic_mv[i] = scaled;
+		pr_debug("%s: DCE run %d, mic_mv = %d\n", __func__, i + 1,
+			 mic_mv[i]);
 	}
 	sitar_turn_onoff_override(codec, false);
 
 	if (sitar_hs_gpio_level_remove(sitar)) {
 		pr_debug("%s: GPIO value is low when determining plug\n",
 			 __func__);
-		return PLUG_TYPE_INVALID;
+		return;
 	}
 
-	if ((plug_type[0] != PLUG_TYPE_GND_MIC_SWAP && !inval)) {
-		for (i = 0 ; i < num_det && !r; i++) {
-			if (mic_mv[i] < plug_type_ptr->v_no_mic)
-				plug_type[i] = PLUG_TYPE_HEADPHONE;
-			else if (mic_mv[i] < plug_type_ptr->v_hs_max)
-				plug_type[i] = PLUG_TYPE_HEADSET;
-			else if (mic_mv[i] > plug_type_ptr->v_hs_max)
-				plug_type[i] = PLUG_TYPE_HIGH_HPH;
-
-			r = sitar_is_inval_ins_range(codec, mic_mv[i], &r);
-			if (!r && i > 0) {
-				if (plug_type[i-1] != plug_type[i])
-					r = true;
-				else
-					r = sitar_is_inval_ins_delta(codec,
-								mic_mv[i],
-								mic_mv[i - 1]);
-			}
-			if (i > 0 && (plug_type[i - 1] != plug_type[i])) {
-				pr_err("%s: Detect attempt %d and %d are not same",
-				__func__, i - 1, i);
-				plug_type[0] = PLUG_TYPE_INVALID;
-				inval = true;
-				break;
-			}
-		}
+	if (sitar_codec_is_invalid_plug(codec, mic_mv, plug_type)) {
+		sitar_schedule_hs_detect_plug(sitar);
+	} else if (plug_type[0] == PLUG_TYPE_HEADPHONE) {
+		sitar_codec_report_plug(codec, 1, SND_JACK_HEADPHONE);
+		sitar_schedule_hs_detect_plug(sitar);
+	} else if (plug_type[0] == PLUG_TYPE_HEADSET) {
+		pr_debug("%s: Valid plug found, determine plug type\n",
+			 __func__);
+		sitar_find_plug_and_report(codec, plug_type[0]);
 	}
 
-	pr_debug("%s: Detected plug type %d\n", __func__, plug_type[0]);
-	return plug_type[0];
 }
 
-/* called under codec_resource_lock acquisition */
 static void sitar_codec_detect_plug_type(struct snd_soc_codec *codec)
 {
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
@@ -4891,7 +4226,7 @@
 		pr_debug("%s: GPIO value is low when determining "
 				 "plug\n", __func__);
 	else
-		sitar_schedule_hs_detect_plug(sitar);
+		sitar_codec_decide_gpio_plug(codec);
 
 	return;
 }
@@ -4905,13 +4240,13 @@
 	pr_debug("%s: enter\n", __func__);
 
 	priv->in_gpio_handler = true;
-	/* Wait here for debounce time */
+	
 	usleep_range(SITAR_GPIO_IRQ_DEBOUNCE_TIME_US,
 		     SITAR_GPIO_IRQ_DEBOUNCE_TIME_US);
 
 	SITAR_ACQUIRE_LOCK(priv->codec_resource_lock);
 
-	/* cancel pending button press */
+	
 	if (sitar_cancel_btn_work(priv))
 		pr_debug("%s: button press is canceled\n", __func__);
 
@@ -4921,10 +4256,10 @@
 		priv->lpi_enabled = false;
 		wmb();
 
-		/* cancel detect plug */
+		
 		sitar_cancel_hs_detect_plug(priv);
 
-		/* Disable Mic Bias pull down and HPH Switch to GND */
+		
 		snd_soc_update_bits(codec, priv->mbhc_bias_regs.ctl_reg, 0x01,
 				    0x00);
 		snd_soc_update_bits(codec, SITAR_A_MBHC_HPH, 0x01, 0x00);
@@ -4933,15 +4268,12 @@
 		priv->lpi_enabled = false;
 		wmb();
 
-		/* cancel detect plug */
+		
 		sitar_cancel_hs_detect_plug(priv);
 
 		if (priv->current_plug == PLUG_TYPE_HEADPHONE) {
 			sitar_codec_report_plug(codec, 0, SND_JACK_HEADPHONE);
 			is_removed = true;
-		} else if (priv->current_plug == PLUG_TYPE_GND_MIC_SWAP) {
-			sitar_codec_report_plug(codec, 0, SND_JACK_UNSUPPORTED);
-			is_removed = true;
 		} else if (priv->current_plug == PLUG_TYPE_HEADSET) {
 			sitar_codec_pause_hs_polling(codec);
 			sitar_codec_cleanup_hs_polling(codec);
@@ -4950,25 +4282,25 @@
 		}
 
 		if (is_removed) {
-			/* Enable Mic Bias pull down and HPH Switch to GND */
+			
 			snd_soc_update_bits(codec,
 					    priv->mbhc_bias_regs.ctl_reg, 0x01,
 					    0x01);
 			snd_soc_update_bits(codec, SITAR_A_MBHC_HPH, 0x01,
 					    0x01);
-			/* Make sure mic trigger is turned off */
+			
 			snd_soc_update_bits(codec,
 					    priv->mbhc_bias_regs.ctl_reg,
 					    0x01, 0x01);
 			snd_soc_update_bits(codec,
 					    priv->mbhc_bias_regs.mbhc_reg,
 					    0x90, 0x00);
-			/* Reset MBHC State Machine */
+			
 			snd_soc_update_bits(codec, SITAR_A_CDC_MBHC_CLK_CTL,
 					    0x08, 0x08);
 			snd_soc_update_bits(codec, SITAR_A_CDC_MBHC_CLK_CTL,
 					    0x08, 0x00);
-			/* Turn off override */
+			
 			sitar_turn_onoff_override(codec, false);
 		}
 	}
@@ -4982,18 +4314,9 @@
 {
 	int r = IRQ_HANDLED;
 	struct snd_soc_codec *codec = data;
-	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
 
 	if (unlikely(wcd9xxx_lock_sleep(codec->control_data) == false)) {
 		pr_warn("%s(): Failed to hold suspend\n", __func__);
-		/*
-		 * Give up this IRQ for now and resend this IRQ so IRQ can be
-		 * handled after system resume
-		 */
-		SITAR_ACQUIRE_LOCK(sitar->codec_resource_lock);
-		sitar->gpio_irq_resend = true;
-		SITAR_RELEASE_LOCK(sitar->codec_resource_lock);
-		wake_lock_timeout(&sitar->irq_resend_wlock, HZ);
 		r = IRQ_NONE;
 	} else {
 		sitar_hs_gpio_handler(codec);
@@ -5014,7 +4337,7 @@
 	sitar->mbhc_cfg.mclk_cb_fn(codec, 0, false);
 	sitar_codec_calibrate_hs_polling(codec);
 
-	/* Enable Mic Bias pull down and HPH Switch to GND */
+	
 	snd_soc_update_bits(codec, sitar->mbhc_bias_regs.ctl_reg,
 						0x01, 0x01);
 	snd_soc_update_bits(codec, SITAR_A_MBHC_HPH,
@@ -5035,7 +4358,7 @@
 					SITAR_IRQ_HPH_PA_OCPL_FAULT);
 		wcd9xxx_enable_irq(codec->control_data,
 					SITAR_IRQ_HPH_PA_OCPR_FAULT);
-		/* Bootup time detection */
+		
 		sitar_hs_gpio_handler(codec);
 	}
 
@@ -5114,7 +4437,7 @@
 	sitar->lpi_enabled = false;
 	sitar_get_mbhc_micbias_regs(codec, &sitar->mbhc_bias_regs);
 
-	/* Put CFILT in fast mode by default */
+	
 	snd_soc_update_bits(codec, sitar->mbhc_bias_regs.cfilt_ctl,
 			    0x40, SITAR_CFILT_FAST_MODE);
 
@@ -5193,42 +4516,22 @@
 	return mask;
 }
 
-void sitar_get_z(struct snd_soc_codec *codec , s16 *dce_z, s16 *sta_z)
-{
-	s16 reg0, reg1;
-	/* Connect micbias to ground and disconnect vddio switch */
-	reg0 = snd_soc_read(codec, SITAR_A_MBHC_SCALING_MUX_1);
-	snd_soc_write(codec, SITAR_A_MBHC_SCALING_MUX_1, 0x81);
-	reg1 = snd_soc_read(codec, SITAR_A_MICB_2_MBHC);
-	snd_soc_update_bits(codec, SITAR_A_MICB_2_MBHC, 1 << 7, 0);
-
-	/* delay 1ms for discharge mic voltage */
-	usleep_range(1000, 1000 + 1000);
-	*sta_z = sitar_codec_sta_dce(codec, 0, false);
-	*dce_z = sitar_codec_sta_dce(codec, 1, false);
-
-	/* Restore defaults */
-	snd_soc_write(codec, SITAR_A_MBHC_SCALING_MUX_1, reg0);
-	snd_soc_write(codec, SITAR_A_MICB_2_MBHC, reg1);
-}
 
 static irqreturn_t sitar_dce_handler(int irq, void *data)
 {
 	int i, mask;
+	short dce, sta, bias_value_dce;
+	s32 mv, stamv, bias_mv_dce;
 	int btn = -1, meas = 0;
 	struct sitar_priv *priv = data;
 	const struct sitar_mbhc_btn_detect_cfg *d =
 	    SITAR_MBHC_CAL_BTN_DET_PTR(priv->mbhc_cfg.calibration);
 	short btnmeas[d->n_btn_meas + 1];
-	short dce[d->n_btn_meas + 1], sta;
-	s32 mv[d->n_btn_meas + 1], mv_s[d->n_btn_meas + 1];
-	s32 stamv, stamv_s;
 	struct snd_soc_codec *codec = priv->codec;
 	struct wcd9xxx *core = dev_get_drvdata(priv->codec->dev->parent);
 	int n_btn_meas = d->n_btn_meas;
 	u8 mbhc_status = snd_soc_read(codec, SITAR_A_CDC_MBHC_B1_STATUS) & 0x3E;
-	bool vddio;
-	s16 dce_z, sta_z;
+
 	pr_debug("%s: enter\n", __func__);
 
 	SITAR_ACQUIRE_LOCK(priv->codec_resource_lock);
@@ -5246,7 +4549,10 @@
 		goto done;
 	}
 
-	/* If GPIO interrupt already kicked in, ignore button press */
+	dce = sitar_codec_read_dce_result(codec);
+	mv = sitar_codec_sta_dce_v(codec, 1, dce);
+
+	
 	if (priv->in_gpio_handler) {
 		pr_debug("%s: GPIO State Changed, ignore button press\n",
 			 __func__);
@@ -5254,12 +4560,6 @@
 		goto done;
 	}
 
-	vddio = (priv->mbhc_data.micb_mv != VDDIO_MICBIAS_MV &&
-		 priv->mbhc_micbias_switched);
-
-	dce[0] = sitar_codec_read_dce_result(codec);
-	sta = sitar_codec_read_sta_result(codec);
-
 	if (mbhc_status != SITAR_MBHC_STATUS_REL_DETECTION) {
 		if (priv->mbhc_last_resume &&
 		    !time_after(jiffies, priv->mbhc_last_resume + HZ)) {
@@ -5269,74 +4569,38 @@
 		} else {
 			pr_debug("%s: Button is already released without "
 				 "resume", __func__);
-			sitar_get_z(codec, &dce_z, &sta_z);
-			stamv = __sitar_codec_sta_dce_v(codec, 0, sta, sta_z);
-			if (vddio)
-				stamv_s = sitar_scale_v_micb_vddio(priv, stamv,
-								   false);
-			else
-				stamv_s = stamv;
-			mv[0] = __sitar_codec_sta_dce_v(codec, 1, dce[0],
-							dce_z);
-			mv_s[0] = vddio ? sitar_scale_v_micb_vddio(priv, mv[0],
-								   false) :
-								   mv[0];
-			btn = sitar_determine_button(priv, mv_s[0]);
+			sta = sitar_codec_read_sta_result(codec);
+			stamv = sitar_codec_sta_dce_v(codec, 0, sta);
+			btn = sitar_determine_button(priv, mv);
 			if (btn != sitar_determine_button(priv, stamv))
 				btn = -1;
 			goto done;
 		}
 	}
 
-	for (meas = 1; ((d->n_btn_meas) && (meas < (d->n_btn_meas + 1)));
-	meas++)
-		dce[meas] = sitar_codec_sta_dce(codec, 1, false);
-
-	sitar_get_z(codec, &dce_z, &sta_z);
-
-	stamv = __sitar_codec_sta_dce_v(codec, 0, sta, sta_z);
-	if (vddio)
-		stamv_s = sitar_scale_v_micb_vddio(priv, stamv, false);
-	else
-		stamv_s = stamv;
 
-	pr_debug("%s: Meas HW - STA 0x%x,%d,%d\n", __func__,
-		sta & 0xFFFF, stamv, stamv_s);
-	pr_info("%s: dce_z after recalibration: %x and sta_z: %x\n", __func__,
-		dce_z, sta_z);
-	/* determine pressed button */
-	mv[0] = __sitar_codec_sta_dce_v(codec, 1, dce[0], dce_z);
-	mv_s[0] = vddio ? sitar_scale_v_micb_vddio(priv, mv[0], false) : mv[0];
-	btnmeas[0] = sitar_determine_button(priv, mv_s[0]);
-	pr_debug("%s: Meas HW - DCE 0x%x,%d,%d button %d\n", __func__,
-		 dce[0] & 0xFFFF, mv[0], mv_s[0], btnmeas[0]);
+	btnmeas[meas++] = sitar_determine_button(priv, mv);
+	pr_debug("%s: meas %d - DCE %d,%d, button %d\n", __func__,
+		 meas - 1, dce, mv, btnmeas[meas - 1]);
 	if (n_btn_meas == 0)
 		btn = btnmeas[0];
-	for (meas = 1; (n_btn_meas && d->n_btn_meas &&
-			(meas < (d->n_btn_meas + 1))); meas++) {
-		mv[meas] = __sitar_codec_sta_dce_v(codec, 1, dce[meas], dce_z);
-		mv_s[meas] = vddio ? sitar_scale_v_micb_vddio(priv, mv[meas],
-				     false) : mv[meas];
-
-		btnmeas[meas] = sitar_determine_button(priv, mv_s[meas]);
-		pr_debug("%s: meas %d - DCE 0x%x,%d,%d, button %d\n",
-			 __func__, meas, dce[meas] & 0xFFFF, mv[meas],
-			 mv_s[meas], btnmeas[meas]);
-		/* if large enough measurements are collected,
-		 * start to check if last all n_btn_con measurements were
-		 * in same button low/high range */
+	for (; ((d->n_btn_meas) && (meas < (d->n_btn_meas + 1))); meas++) {
+		bias_value_dce = sitar_codec_sta_dce(codec, 1, false);
+		bias_mv_dce = sitar_codec_sta_dce_v(codec, 1, bias_value_dce);
+		btnmeas[meas] = sitar_determine_button(priv, bias_mv_dce);
+		pr_debug("%s: meas %d - DCE %d,%d, button %d\n",
+			 __func__, meas, bias_value_dce, bias_mv_dce,
+			 btnmeas[meas]);
 		if (meas + 1 >= d->n_btn_con) {
 			for (i = 0; i < d->n_btn_con; i++)
 				if ((btnmeas[meas] < 0) ||
 				    (btnmeas[meas] != btnmeas[meas - i]))
 					break;
 			if (i == d->n_btn_con) {
-				/* button pressed */
+				
 				btn = btnmeas[meas];
 				break;
 			} else if ((n_btn_meas - meas) < (d->n_btn_con - 1)) {
-				/* if left measurements are less than n_btn_con,
-				 * it's impossible to find button number */
 				break;
 			}
 		}
@@ -5470,10 +4734,8 @@
 
 	if (sitar) {
 		codec = sitar->codec;
-		if ((sitar->hphlocp_cnt < SITAR_OCP_ATTEMPT) &&
-		    (!sitar->hphrocp_cnt)) {
+		if (sitar->hphlocp_cnt++ < SITAR_OCP_ATTEMPT) {
 			pr_info("%s: retry\n", __func__);
-			sitar->hphlocp_cnt++;
 			snd_soc_update_bits(codec, SITAR_A_RX_HPH_OCP_CTL, 0x10,
 					    0x00);
 			snd_soc_update_bits(codec, SITAR_A_RX_HPH_OCP_CTL, 0x10,
@@ -5481,6 +4743,7 @@
 		} else {
 			wcd9xxx_disable_irq(codec->control_data,
 					  SITAR_IRQ_HPH_PA_OCPL_FAULT);
+			sitar->hphlocp_cnt = 0;
 			sitar->hph_status |= SND_JACK_OC_HPHL;
 			if (sitar->mbhc_cfg.headset_jack)
 				sitar_snd_soc_jack_report(sitar,
@@ -5504,10 +4767,8 @@
 
 	if (sitar) {
 		codec = sitar->codec;
-		if ((sitar->hphrocp_cnt < SITAR_OCP_ATTEMPT) &&
-		    (!sitar->hphlocp_cnt)) {
+		if (sitar->hphrocp_cnt++ < SITAR_OCP_ATTEMPT) {
 			pr_info("%s: retry\n", __func__);
-			sitar->hphrocp_cnt++;
 			snd_soc_update_bits(codec, SITAR_A_RX_HPH_OCP_CTL, 0x10,
 					   0x00);
 			snd_soc_update_bits(codec, SITAR_A_RX_HPH_OCP_CTL, 0x10,
@@ -5515,6 +4776,7 @@
 		} else {
 			wcd9xxx_disable_irq(codec->control_data,
 					 SITAR_IRQ_HPH_PA_OCPR_FAULT);
+			sitar->hphrocp_cnt = 0;
 			sitar->hph_status |= SND_JACK_OC_HPHR;
 			if (sitar->mbhc_cfg.headset_jack)
 				sitar_snd_soc_jack_report(sitar,
@@ -5540,7 +4802,7 @@
 
 	snd_soc_update_bits(codec, SITAR_A_CDC_MBHC_INT_CTL, 0x03, 0x00);
 
-	/* Turn off both HPH and MIC line schmitt triggers */
+	
 	snd_soc_update_bits(codec, priv->mbhc_bias_regs.mbhc_reg, 0x90, 0x00);
 	snd_soc_update_bits(codec, SITAR_A_MBHC_HPH, 0x13, 0x00);
 	snd_soc_update_bits(codec, priv->mbhc_bias_regs.ctl_reg, 0x01, 0x00);
@@ -5558,7 +4820,7 @@
 		   priv->mbhc_cfg.gpio_level_insert) {
 		pr_debug("%s: Valid insertion, "
 			 "detect plug type\n", __func__);
-		sitar_schedule_hs_detect_plug(priv);
+		sitar_codec_decide_gpio_plug(codec);
 	} else {
 		pr_debug("%s: Invalid insertion, "
 			 "stop plug detection\n", __func__);
@@ -5579,9 +4841,6 @@
 			&& (mic_mv < plug_type->v_hs_max)) ? true : false;
 }
 
-/* called under codec_resource_lock acquisition
- * returns true if mic voltage range is back to normal insertion
- * returns false either if timedout or removed */
 static bool sitar_hs_remove_settle(struct snd_soc_codec *codec)
 {
 	int i;
@@ -5658,12 +4917,12 @@
 }
 
 
+static unsigned long slimbus_value;
 
 static irqreturn_t sitar_slimbus_irq(int irq, void *data)
 {
 	struct sitar_priv *priv = data;
 	struct snd_soc_codec *codec = priv->codec;
-	unsigned long slimbus_value;
 	int i, j, k, port_id, ch_mask_temp;
 	u8 val;
 
@@ -5723,7 +4982,7 @@
 		goto done;
 	}
 
-	/* Make sure settings are correct */
+	
 	if ((pdata->micbias.ldoh_v > SITAR_LDOH_2P85_V) ||
 	   (pdata->micbias.bias1_cfilt_sel > SITAR_CFILT2_SEL) ||
 	   (pdata->micbias.bias2_cfilt_sel > SITAR_CFILT2_SEL)) {
@@ -5731,7 +4990,7 @@
 		goto done;
 	}
 
-	/* figure out k value */
+	
 	k1 = sitar_find_k_value(pdata->micbias.ldoh_v,
 		pdata->micbias.cfilt1_mv);
 	k2 = sitar_find_k_value(pdata->micbias.ldoh_v,
@@ -5742,26 +5001,36 @@
 		goto done;
 	}
 
-	/* Set voltage level and always use LDO */
+	
 	snd_soc_update_bits(codec, SITAR_A_LDO_H_MODE_1, 0x0C,
 		(pdata->micbias.ldoh_v << 2));
 
 	snd_soc_update_bits(codec, SITAR_A_MICB_CFILT_1_VAL, 0xFC,
-		(k1 << 2));
+		128 );
 	snd_soc_update_bits(codec, SITAR_A_MICB_CFILT_2_VAL, 0xFC,
-		(k2 << 2));
+		128 );
 
 	snd_soc_update_bits(codec, SITAR_A_MICB_1_CTL, 0x60,
 		(pdata->micbias.bias1_cfilt_sel << 5));
 	snd_soc_update_bits(codec, SITAR_A_MICB_2_CTL, 0x60,
 		(pdata->micbias.bias2_cfilt_sel << 5));
 
-	/* Set micbias capless mode */
 	snd_soc_update_bits(codec, SITAR_A_MICB_1_CTL, 0x10,
 		(pdata->micbias.bias1_cap_mode << 4));
 	snd_soc_update_bits(codec, SITAR_A_MICB_2_CTL, 0x10,
 		(pdata->micbias.bias2_cap_mode << 4));
 
+	
+	if (pdata->micbias.bias1_cap_mode == MICBIAS_EXT_BYP_CAP)
+		snd_soc_update_bits(codec, SITAR_A_MICB_1_CTL, 0x0E, 0x00);
+	else
+		snd_soc_update_bits(codec, SITAR_A_MICB_1_CTL, 0x0E, 0x06);
+
+	if (pdata->micbias.bias2_cap_mode == MICBIAS_EXT_BYP_CAP)
+		snd_soc_update_bits(codec, SITAR_A_MICB_2_CTL, 0x0E, 0x00);
+	else
+		snd_soc_update_bits(codec, SITAR_A_MICB_2_CTL, 0x0E, 0x06);
+
 	for (i = 0; i < 6; j++, i += 2) {
 		if (flag & (0x01 << i)) {
 			value = (leg_mode & (0x01 << i)) ? 0x10 : 0x00;
@@ -5797,7 +5066,7 @@
 
 
 	if (pdata->ocp.use_pdata) {
-		/* not defined in CODEC specification */
+		
 		if (pdata->ocp.hph_ocp_limit == 1 ||
 			pdata->ocp.hph_ocp_limit == 5) {
 			rc = -EINVAL;
@@ -5851,31 +5120,24 @@
 };
 
 static const struct sitar_reg_mask_val sitar_codec_reg_init_val[] = {
-	/* Initialize current threshold to 350MA
-	* number of wait and run cycles to 4096
-	*/
 	{SITAR_A_RX_HPH_OCP_CTL, 0xE0, 0x60},
 	{SITAR_A_RX_COM_OCP_COUNT, 0xFF, 0xFF},
 
 	{SITAR_A_QFUSE_CTL, 0xFF, 0x03},
 
-	/* Initialize gain registers to use register gain */
+	
 	{SITAR_A_RX_HPH_L_GAIN, 0x10, 0x10},
 	{SITAR_A_RX_HPH_R_GAIN, 0x10, 0x10},
 	{SITAR_A_RX_LINE_1_GAIN, 0x10, 0x10},
 	{SITAR_A_RX_LINE_2_GAIN, 0x10, 0x10},
 
-	/* Set the MICBIAS default output as pull down*/
-	{SITAR_A_MICB_1_CTL, 0x01, 0x01},
-	{SITAR_A_MICB_2_CTL, 0x01, 0x01},
 
-	/* Initialize mic biases to differential mode */
 	{SITAR_A_MICB_1_INT_RBIAS, 0x24, 0x24},
 	{SITAR_A_MICB_2_INT_RBIAS, 0x24, 0x24},
 
 	{SITAR_A_CDC_CONN_CLSG_CTL, 0x3C, 0x14},
 
-	/* Use 16 bit sample size for TX1 to TX6 */
+	
 	{SITAR_A_CDC_CONN_TX_SB_B1_CTL, 0x30, 0x20},
 	{SITAR_A_CDC_CONN_TX_SB_B2_CTL, 0x30, 0x20},
 	{SITAR_A_CDC_CONN_TX_SB_B3_CTL, 0x30, 0x20},
@@ -5883,15 +5145,15 @@
 	{SITAR_A_CDC_CONN_TX_SB_B5_CTL, 0x30, 0x20},
 	{SITAR_A_CDC_CLK_TX_CLK_EN_B1_CTL, 0x1, 0x1},
 
-	/* Use 16 bit sample size for RX */
+	
 	{SITAR_A_CDC_CONN_RX_SB_B1_CTL, 0xFF, 0xAA},
 	{SITAR_A_CDC_CONN_RX_SB_B2_CTL, 0x02, 0x02},
 
-	/*enable HPF filter for TX paths */
+	
 	{SITAR_A_CDC_TX1_MUX_CTL, 0x8, 0x0},
 	{SITAR_A_CDC_TX2_MUX_CTL, 0x8, 0x0},
 
-	/*enable External clock select*/
+	
 	{SITAR_A_CDC_CLK_MCLK_CTL, 0x01, 0x01},
 };
 
@@ -5923,6 +5185,7 @@
 	u8 sitar_version;
 	int ch_cnt;
 
+	pr_info("%s\n", __func__);
 	codec->control_data = dev_get_drvdata(codec->dev->parent);
 	control = codec->control_data;
 
@@ -5932,21 +5195,13 @@
 		return -ENOMEM;
 	}
 
-	for (i = 0; i < NUM_DECIMATORS; i++) {
-		tx_hpf_work[i].sitar = sitar;
-		tx_hpf_work[i].decimator = i + 1;
-		INIT_DELAYED_WORK(&tx_hpf_work[i].dwork,
-						  tx_hpf_corner_freq_callback);
-	}
 
-
-	/* Make sure mbhc micbias register addresses are zeroed out */
 	memset(&sitar->mbhc_bias_regs, 0,
 		sizeof(struct mbhc_micbias_regs));
 	sitar->cfilt_k_value = 0;
 	sitar->mbhc_micbias_switched = false;
 
-	/* Make sure mbhc intenal calibration data is zeroed out */
+	
 	memset(&sitar->mbhc_data, 0,
 		sizeof(struct mbhc_internal_cal_data));
 	sitar->mbhc_data.t_sta_dce = DEFAULT_DCE_STA_WAIT;
@@ -5971,11 +5226,6 @@
 	if (sitar->intf_type == WCD9XXX_INTERFACE_TYPE_I2C)
 		sitar_i2c_codec_init_reg(codec);
 
-	for (i = 0; i < COMPANDER_MAX; i++) {
-		sitar->comp_enabled[i] = 0;
-		sitar->comp_fs[i] = COMPANDER_FS_48KHZ;
-	}
-
 	ret = sitar_handle_pdata(sitar);
 	if (IS_ERR_VALUE(ret)) {
 		pr_err("%s: bad pdata\n", __func__);
@@ -6069,13 +5319,6 @@
 	}
 	wcd9xxx_disable_irq(codec->control_data, SITAR_IRQ_HPH_PA_OCPR_FAULT);
 
-	/*
-	 * Register suspend lock and notifier to resend edge triggered
-	 * gpio IRQs
-	 */
-	wake_lock_init(&sitar->irq_resend_wlock, WAKE_LOCK_SUSPEND,
-			"sitar_gpio_irq_resend");
-	sitar->gpio_irq_resend = false;
 	for (i = 0; i < ARRAY_SIZE(sitar_dai); i++) {
 		switch (sitar_dai[i].id) {
 		case AIF1_PB:
@@ -6092,6 +5335,8 @@
 		init_waitqueue_head(&sitar->dai[i].dai_wait);
 	}
 
+	INIT_WORK(&sitar->audio_vol_ramp_work.rwork, audio_vol_ramping_func);
+
 	codec->ignore_pmdown_time = 1;
 
 #ifdef CONFIG_DEBUG_FS
@@ -6128,9 +5373,6 @@
 {
 	int i;
 	struct sitar_priv *sitar = snd_soc_codec_get_drvdata(codec);
-
-	wake_lock_destroy(&sitar->irq_resend_wlock);
-
 	wcd9xxx_free_irq(codec->control_data, SITAR_IRQ_SLIMBUS, sitar);
 	wcd9xxx_free_irq(codec->control_data, SITAR_IRQ_MBHC_RELEASE, sitar);
 	wcd9xxx_free_irq(codec->control_data, SITAR_IRQ_MBHC_POTENTIAL, sitar);
@@ -6208,27 +5450,10 @@
 
 static int sitar_resume(struct device *dev)
 {
-	int irq;
 	struct platform_device *pdev = to_platform_device(dev);
 	struct sitar_priv *sitar = platform_get_drvdata(pdev);
 	dev_dbg(dev, "%s: system resume\n", __func__);
-	if (sitar) {
-		SITAR_ACQUIRE_LOCK(sitar->codec_resource_lock);
-		sitar->mbhc_last_resume = jiffies;
-		if (sitar->gpio_irq_resend) {
-			WARN_ON(!sitar->mbhc_cfg.gpio_irq);
-			sitar->gpio_irq_resend = false;
-
-			irq = sitar->mbhc_cfg.gpio_irq;
-			pr_debug("%s: Resending GPIO IRQ %d\n", __func__, irq);
-			irq_set_pending(irq);
-			check_irq_resend(irq_to_desc(irq), irq);
-
-			/* release suspend lock */
-			wake_unlock(&sitar->irq_resend_wlock);
-		}
-		SITAR_RELEASE_LOCK(sitar->codec_resource_lock);
-	}
+	if (sitar != NULL) sitar->mbhc_last_resume = jiffies;
 	return 0;
 }
 
@@ -6241,7 +5466,7 @@
 static int __devinit sitar_probe(struct platform_device *pdev)
 {
 	int ret = 0;
-	pr_err("%s\n", __func__);
+	pr_info("%s\n", __func__);
 #ifdef CONFIG_DEBUG_FS
 	debugfs_poke = debugfs_create_file("TRRS",
 		S_IFREG | S_IRUGO, NULL, (void *) "TRRS", &codec_debug_ops);
